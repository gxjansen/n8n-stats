---
import { formatNumber, formatChange } from '@/lib/utils/formatters';
import MiniSparkline from '@/components/charts/MiniSparkline.astro';
import SourceInfo from '@/components/SourceInfo.astro';

interface SourceAttribution {
  source: string;
  url?: string;
  note?: string;
}

interface Props {
  label: string;
  value: number | string;
  change?: number;
  changeLabel?: string;
  icon?: string;
  href?: string;        // External link (opens new tab)
  to?: string;          // Internal page link
  subtitle?: string;    // Optional subtitle below the value
  valueClass?: string;  // Custom class for value styling
  animate?: boolean;    // Enable count-up animation (default: true for numbers)
  sparklineData?: number[];  // Optional time-series data for sparkline
  sparklineColor?: string;   // Optional custom color for sparkline
  source?: SourceAttribution; // Optional data source attribution
}

const {
  label,
  value,
  change,
  changeLabel = 'vs last week',
  icon,
  href,
  to,
  subtitle,
  valueClass = 'stat-value',
  animate = true,
  sparklineData,
  sparklineColor = '#ff6d5a',
  source,
} = Astro.props;

const isPositive = change !== undefined && change >= 0;
const isClickable = href || to;
const linkProps = href
  ? { href, target: '_blank', rel: 'noopener noreferrer' }
  : to
    ? { href: to }
    : {};

// For numeric values, we'll animate them
const isNumeric = typeof value === 'number';
const displayValue = isNumeric ? formatNumber(value) : value;
const shouldAnimate = animate && isNumeric;
---

{isClickable ? (
  <a
    {...linkProps}
    class="card stat-card block hover:border-n8n-primary/50 hover:bg-gray-800/50 transition-all cursor-pointer group relative"
    data-umami-event="card-click"
    data-umami-event-target={`stat-${label.toLowerCase().replace(/\s+/g, '-')}`}
  >
    {source && (
      <SourceInfo source={source.source} url={source.url} note={source.note} />
    )}
    <div class="flex items-start justify-between">
      <div>
        <p class="stat-label group-hover:text-gray-300 transition-colors">{label}</p>
        <p
          class={`${valueClass} mt-1 ${shouldAnimate ? 'count-up' : ''}`}
          data-target={shouldAnimate ? value : undefined}
          data-formatted={shouldAnimate ? displayValue : undefined}
        >
          {displayValue}
        </p>
        {subtitle && (
          <p class="text-sm text-gray-500 mt-1">{subtitle}</p>
        )}
        {change !== undefined && (
          <p class={`text-sm mt-2 ${isPositive ? 'text-green-400' : 'text-red-400'}`}>
            {formatChange(change)} <span class="text-gray-500">{changeLabel}</span>
          </p>
        )}
      </div>
      <div class="flex flex-col items-end gap-2">
        {sparklineData && sparklineData.length > 1 && (
          <MiniSparkline data={sparklineData} color={sparklineColor} width={64} height={20} />
        )}
        {icon && !sparklineData && (
          <div class="text-n8n-primary text-2xl">
            <Fragment set:html={icon} />
          </div>
        )}
        <svg class="w-4 h-4 text-gray-600 group-hover:text-n8n-primary transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          {href ? (
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
          ) : (
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          )}
        </svg>
      </div>
    </div>
  </a>
) : (
  <div class="card stat-card relative">
    {source && (
      <SourceInfo source={source.source} url={source.url} note={source.note} />
    )}
    <div class="flex items-start justify-between">
      <div>
        <p class="stat-label">{label}</p>
        <p
          class={`${valueClass} mt-1 ${shouldAnimate ? 'count-up' : ''}`}
          data-target={shouldAnimate ? value : undefined}
          data-formatted={shouldAnimate ? displayValue : undefined}
        >
          {displayValue}
        </p>
        {subtitle && (
          <p class="text-sm text-gray-500 mt-1">{subtitle}</p>
        )}
        {change !== undefined && (
          <p class={`text-sm mt-2 ${isPositive ? 'text-green-400' : 'text-red-400'}`}>
            {formatChange(change)} <span class="text-gray-500">{changeLabel}</span>
          </p>
        )}
      </div>
      <div class="flex flex-col items-end gap-2">
        {sparklineData && sparklineData.length > 1 && (
          <MiniSparkline data={sparklineData} color={sparklineColor} width={64} height={20} />
        )}
        {icon && !sparklineData && (
          <div class="text-n8n-primary text-2xl">
            <Fragment set:html={icon} />
          </div>
        )}
      </div>
    </div>
  </div>
)}

<script>
  // Format number with commas (matching formatNumber utility)
  function formatNumberForAnimation(num: number): string {
    return num.toLocaleString('en-US');
  }

  // Easing function for smooth deceleration
  function easeOutQuart(t: number): number {
    return 1 - Math.pow(1 - t, 4);
  }

  function animateCountUp(element: HTMLElement, target: number, duration: number = 1500) {
    const start = 0;
    const startTime = performance.now();

    function update(currentTime: number) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easedProgress = easeOutQuart(progress);
      const currentValue = Math.round(start + (target - start) * easedProgress);

      element.textContent = formatNumberForAnimation(currentValue);

      if (progress < 1) {
        requestAnimationFrame(update);
      } else {
        // Ensure we end with the exact formatted value
        const formatted = element.dataset.formatted;
        if (formatted) {
          element.textContent = formatted;
        }
      }
    }

    requestAnimationFrame(update);
  }

  function initStatCardAnimations() {
    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const countUpElements = document.querySelectorAll<HTMLElement>('.count-up:not(.animated)');

    if (prefersReducedMotion) {
      // Skip animation, show final values immediately
      countUpElements.forEach((el) => {
        el.classList.add('animated');
      });
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const el = entry.target as HTMLElement;
            const target = parseFloat(el.dataset.target || '0');

            if (!el.classList.contains('animated') && target > 0) {
              el.classList.add('animated');
              // Start from 0
              el.textContent = '0';
              // Animate to target
              animateCountUp(el, target);
            }

            observer.unobserve(el);
          }
        });
      },
      {
        threshold: 0.3,
        rootMargin: '0px 0px -50px 0px',
      }
    );

    countUpElements.forEach((el) => observer.observe(el));
  }

  // Run on initial load and after view transitions
  initStatCardAnimations();
  document.addEventListener('astro:after-swap', initStatCardAnimations);
</script>
