---
/**
 * Milestone Prediction Card
 *
 * Displays a predicted date for reaching a milestone value.
 * Shows confidence level and days until milestone.
 */

import { formatNumber } from '@/lib/utils/formatters';
import { formatPredictedDate, formatDaysUntil } from '@/lib/utils/predictions';
import SourceInfo from '@/components/SourceInfo.astro';

interface SourceAttribution {
  source: string;
  url?: string;
  note?: string;
}

interface Props {
  label: string;
  milestone: number;
  predictedDate: Date | null;
  daysUntil: number | null;
  confidence: 'high' | 'medium' | 'low';
  currentValue: number;
  icon?: string;
  source?: SourceAttribution;
}

const {
  label,
  milestone,
  predictedDate,
  daysUntil,
  confidence,
  currentValue,
  icon = 'ðŸŽ¯',
  source,
} = Astro.props;

// Calculate progress percentage
const progress = Math.min((currentValue / milestone) * 100, 100);
const remaining = milestone - currentValue;

// Confidence colors
const confidenceColors = {
  high: 'text-green-400',
  medium: 'text-yellow-400',
  low: 'text-gray-500',
};

const confidenceLabels = {
  high: 'High confidence',
  medium: 'Medium confidence',
  low: 'Low confidence',
};

// Generate unique ID for this instance
const uniqueId = `milestone-${Math.random().toString(36).slice(2, 9)}`;
---

<div class="card milestone-card p-4 relative" id={uniqueId}>
  {source && (
    <SourceInfo source={source.source} url={source.url} note={source.note} />
  )}
  <div class="flex items-start justify-between mb-3">
    <div>
      <span class="text-2xl">{icon}</span>
      <h3 class="text-sm font-medium text-gray-400 mt-1">{label}</h3>
    </div>
    <span class={`text-xs ${confidenceColors[confidence]} pr-5`}>
      {confidenceLabels[confidence]}
    </span>
  </div>

  <div class="mb-3">
    <div
      class="text-2xl font-bold text-white milestone-value"
      data-target={milestone}
      data-formatted={formatNumber(milestone)}
    >
      {formatNumber(milestone)}
    </div>
    {predictedDate ? (
      <div class="text-sm text-n8n-primary mt-1">
        ~{formatPredictedDate(predictedDate)}
      </div>
    ) : (
      <div class="text-sm text-gray-500 mt-1">
        Unable to predict
      </div>
    )}
  </div>

  {daysUntil !== null && daysUntil > 0 && (
    <div class="text-xs text-gray-400 mb-3">
      {formatDaysUntil(daysUntil)} away
    </div>
  )}

  <!-- Progress bar -->
  <div class="space-y-1">
    <div class="flex justify-between text-xs text-gray-500">
      <span>Current: {formatNumber(currentValue)}</span>
      <span class="milestone-pct" data-target={progress.toFixed(1)}>{progress.toFixed(1)}%</span>
    </div>
    <div class="h-2 bg-gray-800 rounded-full overflow-hidden">
      <div
        class="milestone-bar h-full bg-gradient-to-r from-n8n-primary to-purple-500 rounded-full"
        data-target-width={progress}
        style={`--target-width: ${progress}%;`}
      />
    </div>
    <div class="text-xs text-gray-500 text-right">
      {formatNumber(remaining)} to go
    </div>
  </div>
</div>

<style>
  .milestone-bar {
    width: 0;
    transition: none;
  }

  .milestone-card.is-visible .milestone-bar {
    animation: fillMilestoneBar 1.2s ease-out forwards;
    animation-delay: 300ms;
  }

  @keyframes fillMilestoneBar {
    from {
      width: 0;
    }
    to {
      width: var(--target-width);
    }
  }

  /* Reduced motion: show immediately without animation */
  @media (prefers-reduced-motion: reduce) {
    .milestone-bar {
      animation: none !important;
      width: var(--target-width) !important;
    }
  }
</style>

<script>
  // Easing function for smooth deceleration
  function easeOutQuart(t: number): number {
    return 1 - Math.pow(1 - t, 4);
  }

  function formatNumberForAnimation(num: number): string {
    return Math.round(num).toLocaleString('en-US');
  }

  function animateMilestoneCountUp(element: HTMLElement, target: number, duration: number = 1500) {
    const start = 0;
    const startTime = performance.now();
    const formatted = element.dataset.formatted || formatNumberForAnimation(target);

    function update(currentTime: number) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easedProgress = easeOutQuart(progress);
      const currentValue = Math.round(start + (target - start) * easedProgress);

      element.textContent = formatNumberForAnimation(currentValue);

      if (progress < 1) {
        requestAnimationFrame(update);
      } else {
        element.textContent = formatted;
      }
    }

    requestAnimationFrame(update);
  }

  function animatePercentage(element: HTMLElement, target: number, duration: number = 1200) {
    const start = 0;
    const startTime = performance.now();

    function update(currentTime: number) {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easedProgress = easeOutQuart(progress);
      const currentValue = start + (target - start) * easedProgress;

      element.textContent = currentValue.toFixed(1) + '%';

      if (progress < 1) {
        requestAnimationFrame(update);
      }
    }

    requestAnimationFrame(update);
  }

  function initMilestoneAnimations() {
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const cards = document.querySelectorAll<HTMLElement>('.milestone-card:not(.animated)');

    if (prefersReducedMotion) {
      cards.forEach((card) => card.classList.add('animated', 'is-visible'));
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target as HTMLElement;

            if (!card.classList.contains('animated')) {
              card.classList.add('animated', 'is-visible');

              // Animate milestone value
              const valueEl = card.querySelector<HTMLElement>('.milestone-value');
              if (valueEl) {
                const target = parseFloat(valueEl.dataset.target || '0');
                if (target > 0) {
                  valueEl.textContent = '0';
                  animateMilestoneCountUp(valueEl, target);
                }
              }

              // Animate percentage
              const pctEl = card.querySelector<HTMLElement>('.milestone-pct');
              if (pctEl) {
                const target = parseFloat(pctEl.dataset.target || '0');
                pctEl.textContent = '0%';
                setTimeout(() => animatePercentage(pctEl, target), 300);
              }
            }

            observer.unobserve(card);
          }
        });
      },
      {
        threshold: 0.3,
        rootMargin: '0px 0px -50px 0px',
      }
    );

    cards.forEach((card) => observer.observe(card));
  }

  // Run on initial load and after view transitions
  initMilestoneAnimations();
  document.addEventListener('astro:after-swap', initMilestoneAnimations);
</script>
