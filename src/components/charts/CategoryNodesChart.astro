---
/**
 * Category Nodes Grouped Horizontal Bar Chart
 *
 * Shows top nodes per category in a compact grouped bar format.
 * Categories on Y-axis, nodes as grouped horizontal bars.
 */

interface NodeData {
  displayName: string;
  count: number;
  category: string;
}

interface Props {
  data: Record<string, NodeData[]>;
  categoryOrder: string[];
  categoryColors: Record<string, string>;
  nodesPerCategory?: number;
}

const { data, categoryOrder, categoryColors, nodesPerCategory = 5 } = Astro.props;

// Prepare chart data: top N nodes per category
const chartData = categoryOrder
  .filter(cat => data[cat]?.length > 0)
  .map(category => ({
    category,
    color: categoryColors[category] || '#7c8798',
    nodes: data[category].slice(0, nodesPerCategory).map(n => ({
      name: n.displayName,
      count: n.count,
    })),
  }));
---

<div id="category-nodes-chart-container" class="card">
  <div class="relative" style={`height: ${chartData.length * 120 + 60}px; min-height: 400px;`}>
    <canvas id="category-nodes-chart"></canvas>
  </div>
</div>

<script define:vars={{ chartData, nodesPerCategory }}>
  window.__categoryNodesData = chartData;
  window.__nodesPerCategory = nodesPerCategory;
</script>

<script>
  import Chart from 'chart.js/auto';

  interface NodeEntry {
    name: string;
    count: number;
  }

  interface CategoryData {
    category: string;
    color: string;
    nodes: NodeEntry[];
  }

  function initCategoryNodesChart() {
    const canvas = document.getElementById('category-nodes-chart') as HTMLCanvasElement;
    const chartData = (window as any).__categoryNodesData as CategoryData[];
    const nodesPerCategory = (window as any).__nodesPerCategory as number;

    if (!chartData || chartData.length === 0) return;

    // Generate position colors (darker to lighter for rank 1-N)
    const positionOpacities = [1, 0.75, 0.55, 0.4, 0.3];

    // Prepare datasets: one dataset per position (1st node, 2nd node, etc.)
    const datasets = [];
    for (let i = 0; i < nodesPerCategory; i++) {
      datasets.push({
        label: `#${i + 1}`,
        data: chartData.map(cat => cat.nodes[i]?.count || 0),
        backgroundColor: chartData.map(cat => {
          const hex = cat.color;
          const opacity = positionOpacities[i] || 0.25;
          // Convert hex to rgba
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }),
        borderColor: chartData.map(cat => cat.color),
        borderWidth: 1,
        borderRadius: 4,
        // Store node names for tooltips
        nodeNames: chartData.map(cat => cat.nodes[i]?.name || ''),
      });
    }

    new Chart(canvas, {
      type: 'bar',
      data: {
        labels: chartData.map(cat => cat.category),
        datasets,
      },
      options: {
        indexAxis: 'y',
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            enabled: true,
            backgroundColor: '#1e1e1e',
            titleColor: '#fff',
            bodyColor: '#9ca3af',
            borderColor: '#333',
            borderWidth: 1,
            padding: 12,
            callbacks: {
              title: (items) => {
                if (!items.length) return '';
                const item = items[0];
                return chartData[item.dataIndex]?.category || '';
              },
              label: (ctx) => {
                const dataset = ctx.dataset as any;
                const nodeName = dataset.nodeNames?.[ctx.dataIndex] || '';
                const count = ctx.raw as number;
                if (!nodeName || count === 0) return '';
                return `${nodeName}: ${count.toLocaleString()} templates`;
              },
            },
          },
        },
        scales: {
          x: {
            stacked: false,
            grid: {
              color: 'rgba(255, 255, 255, 0.1)',
            },
            ticks: {
              color: '#9ca3af',
              callback: (value) => {
                if (typeof value === 'number') {
                  if (value >= 1000) return (value / 1000).toFixed(1) + 'k';
                  return value;
                }
                return value;
              },
            },
          },
          y: {
            stacked: false,
            grid: {
              display: false,
            },
            ticks: {
              color: '#fff',
              font: {
                size: 12,
                weight: 'bold',
              },
            },
          },
        },
      },
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCategoryNodesChart);
  } else {
    initCategoryNodesChart();
  }
</script>
