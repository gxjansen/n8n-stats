---
/**
 * Category Treemap Chart
 *
 * Visualizes category distribution as a treemap where:
 * - Rectangle size = number of templates in category
 * - Color = distinct color per category
 */

interface Props {
  data: Array<{
    name: string;
    count: number;
  }>;
}

const { data } = Astro.props;
---

<div id="category-treemap-container" class="card">
  <div class="relative" style="height: 350px;">
    <canvas id="category-treemap-chart"></canvas>
  </div>
  <div id="category-treemap-loading" class="absolute inset-0 flex items-center justify-center bg-n8n-card/80">
    <span class="text-gray-400">Loading treemap...</span>
  </div>
</div>

<script define:vars={{ data }}>
  window.__categoryTreemapData = data;
</script>

<script>
  import Chart from 'chart.js/auto';
  import { TreemapController, TreemapElement } from 'chartjs-chart-treemap';

  // Register the treemap plugin
  Chart.register(TreemapController, TreemapElement);

  interface CategoryDataPoint {
    name: string;
    count: number;
  }

  const CATEGORY_COLORS: Record<string, string> = {
    'AI': '#7c3aed',           // Vibrant purple
    'Multimodal AI': '#8b5cf6', // Purple
    'AI Summarization': '#a855f7', // Light purple
    'AI Chatbot': '#6d28d9',   // Deep purple
    'Marketing': '#dc2626',    // Red
    'Sales': '#2563eb',        // Blue
    'IT Ops': '#0891b2',       // Cyan
    'Content Creation': '#ca8a04', // Amber
    'Document Ops': '#ea580c', // Orange
    'Support': '#059669',      // Emerald
    'Other': '#4b5563',        // Gray
  };

  // Fallback colors - vibrant, saturated for white text contrast
  const FALLBACK_COLORS = [
    '#dc2626', '#2563eb', '#059669', '#ca8a04', '#7c3aed',
    '#db2777', '#0891b2', '#16a34a', '#d97706', '#4f46e5',
    '#be185d', '#0d9488', '#65a30d', '#c026d3', '#0284c7',
  ];

  function getColorForCategory(name: string, index: number): string {
    return CATEGORY_COLORS[name] || FALLBACK_COLORS[index % FALLBACK_COLORS.length];
  }

  // Build a color map for quick lookup
  let categoryColorMap: Record<string, string> = {};

  function initTreemap() {
    const canvas = document.getElementById('category-treemap-chart') as HTMLCanvasElement;
    const loadingEl = document.getElementById('category-treemap-loading');
    const data = (window as any).__categoryTreemapData as CategoryDataPoint[];

    if (!data || data.length === 0) {
      loadingEl?.classList.add('hidden');
      return;
    }

    loadingEl?.classList.add('hidden');

    // Build color map from category names
    data.forEach((item, index) => {
      categoryColorMap[item.name] = getColorForCategory(item.name, index);
    });

    const chart = new Chart(canvas, {
      type: 'treemap',
      data: {
        datasets: [{
          label: 'Templates by Category',
          tree: data,
          key: 'count',
          groups: ['name'],
          backgroundColor: (ctx: any) => {
            if (ctx.type !== 'data') return 'transparent';
            const item = ctx.raw;
            // Get category name from grouped data (g) or _data
            const name = item.g || item._data?.name || '';
            return categoryColorMap[name] || '#7c3aed';
          },
          borderColor: '#1a1a2e',
          borderWidth: 2,
          spacing: 2,
          labels: {
            display: true,
            align: 'center',
            position: 'middle',
            formatter: (ctx: any) => {
              const item = ctx.raw;
              if (item.w < 80 || item.h < 40) return '';
              const name = item._data?.name || item.g || '';
              const count = item._data?.count || item.v || 0;
              return [name, count.toLocaleString()];
            },
            color: '#fff',
            font: {
              size: 12,
              weight: 'bold',
            },
          },
        }],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        onClick: (_event: any, elements: any[]) => {
          if (elements.length > 0) {
            const element = elements[0];
            const item = (chart.data.datasets[0] as any).tree[element.index];
            const categoryName = item?.name || '';
            if (categoryName) {
              // Open n8n.io filtered by category
              const url = `https://n8n.io/workflows/?category=${encodeURIComponent(categoryName)}`;
              window.open(url, '_blank', 'noopener,noreferrer');
            }
          }
        },
        onHover: (event: any, elements: any[]) => {
          const target = event.native?.target as HTMLElement;
          if (target) {
            target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
          }
        },
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            backgroundColor: '#1e1e1e',
            titleColor: '#fff',
            bodyColor: '#9ca3af',
            borderColor: '#333',
            borderWidth: 1,
            callbacks: {
              title: (items: any[]) => {
                if (!items.length) return '';
                const item = items[0].raw;
                return item._data?.name || item.g || '';
              },
              label: (ctx: any) => {
                const item = ctx.raw;
                const count = item._data?.count || item.v || 0;
                return `${count.toLocaleString()} templates`;
              },
              afterLabel: () => 'Click to view on n8n.io',
            },
          },
        },
      },
    });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTreemap);
  } else {
    initTreemap();
  }
</script>

<style>
  #category-treemap-container {
    position: relative;
  }
</style>
