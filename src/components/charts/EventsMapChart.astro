---
/**
 * Events Map Chart
 * Displays event locations on a world map using Robinson projection
 * with country highlighting for countries that have events.
 *
 * Map source: SVG-World-Map by Raphael Lepuschitz (MIT License)
 * https://github.com/raphaellepuschitz/SVG-World-Map
 */

interface Location {
  name: string;
  city: string;
  country: string;
  countryCode?: string;
  lat: number;
  lng: number;
  eventCount: number;
  totalRegistrations: number;
}

interface Props {
  locations: Location[];
  highlightedCountries?: string[]; // ISO 2-letter country codes
  legendLabels?: {
    location?: string;
    multiple?: string;
    country?: string;
  };
}

const { locations, highlightedCountries = [], legendLabels = {} } = Astro.props;

// Default legend labels (can be overridden for different contexts like ambassadors)
// Set to null/undefined to hide specific legend items
const legend = {
  location: legendLabels.location === null ? null : (legendLabels.location || 'Event location'),
  multiple: legendLabels.multiple === null ? null : (legendLabels.multiple || 'Multiple events'),
  country: legendLabels.country === null ? null : (legendLabels.country || 'Country with events'),
};

// Robinson projection parameters
// Lookup table for Robinson projection (latitude in 5° increments)
// PLEN = parallel length factor, PDFE = distance from equator factor
const robinsonTable = [
  { lat: 0, plen: 1.0000, pdfe: 0.0000 },
  { lat: 5, plen: 0.9986, pdfe: 0.0620 },
  { lat: 10, plen: 0.9954, pdfe: 0.1240 },
  { lat: 15, plen: 0.9900, pdfe: 0.1860 },
  { lat: 20, plen: 0.9822, pdfe: 0.2480 },
  { lat: 25, plen: 0.9730, pdfe: 0.3100 },
  { lat: 30, plen: 0.9600, pdfe: 0.3720 },
  { lat: 35, plen: 0.9427, pdfe: 0.4340 },
  { lat: 40, plen: 0.9216, pdfe: 0.4958 },
  { lat: 45, plen: 0.8962, pdfe: 0.5571 },
  { lat: 50, plen: 0.8679, pdfe: 0.6176 },
  { lat: 55, plen: 0.8350, pdfe: 0.6769 },
  { lat: 60, plen: 0.7986, pdfe: 0.7346 },
  { lat: 65, plen: 0.7597, pdfe: 0.7903 },
  { lat: 70, plen: 0.7186, pdfe: 0.8435 },
  { lat: 75, plen: 0.6732, pdfe: 0.8936 },
  { lat: 80, plen: 0.6213, pdfe: 0.9394 },
  { lat: 85, plen: 0.5722, pdfe: 0.9761 },
  { lat: 90, plen: 0.5322, pdfe: 1.0000 },
];

// Interpolate Robinson projection values for any latitude
function interpolateRobinson(absLat: number): { plen: number; pdfe: number } {
  const lat = Math.min(90, Math.abs(absLat));
  const index = Math.floor(lat / 5);
  const nextIndex = Math.min(index + 1, robinsonTable.length - 1);
  const t = (lat - index * 5) / 5;

  const plen = robinsonTable[index].plen + t * (robinsonTable[nextIndex].plen - robinsonTable[index].plen);
  const pdfe = robinsonTable[index].pdfe + t * (robinsonTable[nextIndex].pdfe - robinsonTable[index].pdfe);

  return { plen, pdfe };
}

// SVG dimensions for Robinson projection (matching world-robinson.svg)
const mapWidth = 1000;
const mapHeight = 507.209;
const centerY = mapHeight / 2;

// Calibrated projection parameters using country center positions:
// - GB center at x≈469 (London at lng≈0°)
// - JP center at x≈825 (Tokyo at lng≈140°)
// Solving for center and scale gives these values:
const centerX = 469.3;  // X position for longitude 0°
const scale = 182.91;   // Unified scale factor for both X and Y

// Robinson projection conversion
// Converts lat/lng to x/y coordinates on the SVG
function latLngToXY(lat: number, lng: number): { x: number; y: number } {
  const { plen, pdfe } = interpolateRobinson(lat);

  // Normalize longitude to [-180, 180]
  const normLng = ((lng + 180) % 360) - 180;

  // X: Robinson projection formula with calibrated scale
  let x = centerX + scale * 0.8487 * (normLng * Math.PI / 180) * plen;

  // SVG-specific corrections for regions where country boundaries
  // don't perfectly match the Robinson projection formula

  // Europe/Middle East (0-50°): shift markers slightly right
  if (normLng > 0 && normLng <= 50) {
    x += 5;
  }
  // Eastern Asia (>100°): gradual rightward correction
  else if (normLng > 100) {
    x += (normLng - 100) * 0.6;
  }

  // Y: Robinson projection formula (north is up, so subtract from center)
  let y = centerY - scale * 1.3523 * pdfe * (lat >= 0 ? 1 : -1);

  // Southern Canada / Great Lakes region: shift markers slightly north
  // to ensure they appear clearly inside Canada's SVG boundary
  if (lat >= 40 && lat <= 55 && normLng >= -100 && normLng <= -50) {
    y -= 8;
  }

  return { x, y };
}

// Process locations for display
const markers = locations.map(loc => {
  const { x, y } = latLngToXY(loc.lat, loc.lng);
  // Size based on event count (min 4, max 12)
  const size = Math.min(12, Math.max(4, 2 + loc.eventCount * 1.5));
  return {
    ...loc,
    x,
    y,
    size,
  };
});

// Get unique country codes that have events
const countriesWithEvents = new Set(highlightedCountries);

const viewBox = `0 0 ${mapWidth} ${mapHeight}`;
---

<div id="events-map-container" class="card">
  <div class="relative overflow-hidden rounded-lg">
    <!-- World map SVG container -->
    <div class="map-wrapper relative">
      <!-- Base world map (loaded via object for styling access) -->
      <object
        id="world-map-svg"
        data="/images/world-robinson.svg"
        type="image/svg+xml"
        class="w-full h-auto max-h-[350px] md:max-h-[450px]"
        aria-label="World map showing event locations"
      >
        Your browser does not support SVG
      </object>

      <!-- Overlay SVG for markers (positioned absolutely on top) -->
      <svg
        viewBox={viewBox}
        class="absolute inset-0 w-full h-full pointer-events-none max-h-[350px] md:max-h-[450px]"
      >
        <!-- Event markers -->
        <g class="markers pointer-events-auto">
          {markers.map((marker, index) => (
            <g
              class="marker-group"
              data-city={marker.city}
              data-country={marker.country}
              data-events={marker.eventCount}
              data-registrations={marker.totalRegistrations}
            >
              <!-- Glow effect -->
              <circle
                cx={marker.x}
                cy={marker.y}
                r={marker.size + 6}
                fill="url(#markerGlow)"
                opacity="0.8"
              />
              <!-- Main marker -->
              <circle
                cx={marker.x}
                cy={marker.y}
                r={marker.size}
                fill="#ff6d5a"
                stroke="#fff"
                stroke-width="1.5"
                class="marker"
                style={`animation-delay: ${index * 50}ms`}
              />
              <!-- Event count label for larger markers -->
              {marker.eventCount > 1 && (
                <text
                  x={marker.x}
                  y={marker.y + 3}
                  text-anchor="middle"
                  fill="#fff"
                  font-size="9"
                  font-weight="bold"
                >
                  {marker.eventCount}
                </text>
              )}
            </g>
          ))}
        </g>

        <!-- Gradient definitions -->
        <defs>
          <radialGradient id="markerGlow">
            <stop offset="0%" stop-color="#ff6d5a" stop-opacity="0.9" />
            <stop offset="100%" stop-color="#ff6d5a" stop-opacity="0" />
          </radialGradient>
        </defs>
      </svg>
    </div>

    <!-- Tooltip -->
    <div
      id="map-tooltip"
      class="absolute hidden bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-sm shadow-xl pointer-events-none z-10"
    >
      <div class="font-semibold text-white" id="tooltip-city"></div>
      <div class="text-gray-400 text-xs" id="tooltip-country"></div>
      <div class="text-n8n-primary mt-1 font-medium" id="tooltip-events"></div>
    </div>
  </div>

  <!-- Legend -->
  <div class="flex flex-wrap items-center justify-center gap-4 md:gap-6 mt-4 text-sm text-gray-400">
    {legend.location && (
      <div class="flex items-center gap-2">
        <span class="w-3 h-3 rounded-full bg-[#ff6d5a]"></span>
        <span>{legend.location}</span>
      </div>
    )}
    {legend.multiple && (
      <div class="flex items-center gap-2">
        <span class="w-5 h-5 rounded-full bg-[#ff6d5a] flex items-center justify-center text-xs text-white font-bold">3</span>
        <span>{legend.multiple}</span>
      </div>
    )}
    {legend.country && (
      <div class="flex items-center gap-2">
        <span class="w-4 h-3 rounded-sm" style="background: rgba(255, 109, 90, 0.3); border: 1px solid rgba(255, 109, 90, 0.5);"></span>
        <span>{legend.country}</span>
      </div>
    )}
  </div>
</div>

<!-- Pass highlighted countries to JavaScript -->
<script define:vars={{ countriesWithEvents: Array.from(countriesWithEvents) }}>
  window.__highlightedCountries = countriesWithEvents;
</script>

<style>
  .map-wrapper {
    background: transparent;
    /* Aspect ratio matches the SVG (1000 x 507.209) to prevent layout collapse */
    aspect-ratio: 1000 / 507;
  }

  .marker {
    cursor: pointer;
  }

  .marker {
    animation: markerPulse 3s ease-in-out infinite;
  }

  @keyframes markerPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.75; }
  }
</style>

<script>
  function initEventsMap() {
    const mapObject = document.getElementById('world-map-svg') as HTMLObjectElement;
    const tooltip = document.getElementById('map-tooltip');
    const tooltipCity = document.getElementById('tooltip-city');
    const tooltipCountry = document.getElementById('tooltip-country');
    const tooltipEvents = document.getElementById('tooltip-events');
    const markers = document.querySelectorAll('.marker-group');

    // Get highlighted countries from the window object
    const highlightedCountries = (window as any).__highlightedCountries || [];

    // Function to style the SVG map for dark theme
    function styleSvgMap(svgDoc: Document) {
      // Style the base map background - make transparent
      const worldRect = svgDoc.getElementById('World');
      if (worldRect) {
        worldRect.setAttribute('fill', 'transparent');
      }

      // Make ocean/water transparent to blend with card background
      const ocean = svgDoc.getElementById('Ocean');
      if (ocean) {
        ocean.setAttribute('fill', 'transparent');
        ocean.setAttribute('stroke', 'none');
      }

      // Style country groups - countries are <g> elements with ISO code IDs containing child paths
      const allGroups = svgDoc.querySelectorAll('g[id]');
      allGroups.forEach((group: Element) => {
        const countryCode = group.getAttribute('id');
        if (!countryCode || countryCode.length !== 2) return; // Country codes are 2 letters

        const hasEvents = highlightedCountries.includes(countryCode);
        const paths = group.querySelectorAll('path');

        paths.forEach((path: Element) => {
          if (hasEvents) {
            // Highlighted country style
            path.setAttribute('fill', 'rgba(255, 109, 90, 0.25)');
            path.setAttribute('stroke', 'rgba(255, 109, 90, 0.5)');
            path.setAttribute('stroke-width', '0.5');
          } else {
            // Default country style - subtle outline on dark background
            path.setAttribute('fill', '#252540');
            path.setAttribute('stroke', '#3a3a5e');
            path.setAttribute('stroke-width', '0.3');
          }
        });
      });

      // Also style any standalone paths (Ocean, borders, etc.)
      const standalonePaths = svgDoc.querySelectorAll('svg > path, svg > g:not([id]) path');
      standalonePaths.forEach((path: Element) => {
        const id = path.getAttribute('id');
        if (id === 'Ocean' || id === 'World') return; // Already handled
        // Style as default land
        path.setAttribute('fill', '#252540');
        path.setAttribute('stroke', '#3a3a5e');
        path.setAttribute('stroke-width', '0.3');
      });
    }

    // Apply styling to SVG map
    if (mapObject) {
      // Check if SVG is already loaded
      if (mapObject.contentDocument && mapObject.contentDocument.querySelector('svg')) {
        styleSvgMap(mapObject.contentDocument);
      }
      // Also listen for load event in case it hasn't loaded yet
      mapObject.addEventListener('load', () => {
        if (mapObject.contentDocument) {
          styleSvgMap(mapObject.contentDocument);
        }
      });
    }

    // Tooltip functionality for markers
    if (!tooltip || !tooltipCity || !tooltipCountry || !tooltipEvents) return;

    markers.forEach(marker => {
      marker.addEventListener('mouseenter', () => {
        const city = marker.getAttribute('data-city') || 'Unknown';
        const country = marker.getAttribute('data-country') || '';
        const events = marker.getAttribute('data-events') || '1';
        const registrations = marker.getAttribute('data-registrations') || '0';

        tooltipCity.textContent = city || country;
        tooltipCountry.textContent = country;
        tooltipEvents.textContent = `${events} event${parseInt(events) !== 1 ? 's' : ''} · ${parseInt(registrations).toLocaleString()} registrations`;

        tooltip.classList.remove('hidden');
      });

      marker.addEventListener('mousemove', (e) => {
        const container = document.getElementById('events-map-container');
        if (!container) return;

        const rect = container.getBoundingClientRect();
        const mouseEvent = e as MouseEvent;
        const x = mouseEvent.clientX - rect.left;
        const y = mouseEvent.clientY - rect.top;

        // Position tooltip, keeping it within bounds
        const tooltipRect = tooltip.getBoundingClientRect();
        let left = x + 15;
        let top = y - 10;

        if (left + tooltipRect.width > rect.width) {
          left = x - tooltipRect.width - 15;
        }

        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      });

      marker.addEventListener('mouseleave', () => {
        tooltip.classList.add('hidden');
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEventsMap);
  } else {
    initEventsMap();
  }
</script>
