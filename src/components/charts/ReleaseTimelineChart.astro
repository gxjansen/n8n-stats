---
/**
 * Release Timeline Chart
 *
 * Shows n8n releases on a horizontal timeline starting from 1.0.
 * - Excludes pre-releases
 * - Different colors for 1.x (blue) and 2.x (orange/primary) series
 * - Filterable by date range
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';

// Load releases from stored data (no API calls during build)
let allReleases: Array<{ tagName: string; publishedAt: string; htmlUrl: string; prerelease: boolean }> = [];
try {
  const releasesPath = join(process.cwd(), 'public', 'data', 'github-releases.json');
  if (existsSync(releasesPath)) {
    allReleases = JSON.parse(readFileSync(releasesPath, 'utf-8'));
  }
} catch (e) { /* use empty array */ }

// Filter: official releases only, starting from 1.0 (no 0.x versions)
const releases = allReleases
  .filter(r => !r.prerelease)
  .filter(r => {
    // Include 1.x and 2.x releases only
    const tag = r.tagName;
    return tag.startsWith('n8n@1.') || tag.startsWith('n8n@2.') ||
           tag.startsWith('1.') || tag.startsWith('2.');
  })
  .map(r => ({
    tag: r.tagName,
    date: r.publishedAt,
    url: r.htmlUrl,
    series: r.tagName.startsWith('n8n@1.') || r.tagName.startsWith('1.') ? '1.x' : '2.x',
  }))
  .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

// Pass data to client
const releaseData = JSON.stringify(releases);
---

<div id="release-timeline-container" class="card">
  <div class="flex flex-wrap items-center justify-between gap-4 mb-4">
    <div class="flex items-center gap-4">
      <div class="flex items-center gap-2">
        <label class="text-sm text-gray-400">Range:</label>
        <select id="release-date-range" class="bg-n8n-darker border border-n8n-border rounded px-3 py-1.5 text-sm text-gray-300 focus:outline-none focus:border-n8n-primary">
          <option value="12">Last 12 months</option>
          <option value="24" selected>Last 24 months</option>
          <option value="36">Last 3 years</option>
          <option value="all">All time</option>
        </select>
      </div>
      <span class="flex items-center gap-2 text-sm">
        <span class="w-3 h-3 rounded-full bg-[#36a2eb]"></span>
        <span class="text-gray-400">1.x series</span>
      </span>
      <span class="flex items-center gap-2 text-sm">
        <span class="w-3 h-3 rounded-full bg-[#ff6d5a]"></span>
        <span class="text-gray-400">2.x series</span>
      </span>
    </div>
    <span id="release-count" class="text-sm text-gray-500">{releases.length} releases</span>
  </div>

  <div class="relative" style="height: 200px;">
    <canvas id="release-timeline-chart"></canvas>
  </div>

  <div id="release-timeline-loading" class="absolute inset-0 flex items-center justify-center bg-n8n-card/80">
    <span class="text-gray-400">Loading releases...</span>
  </div>
</div>

<script define:vars={{ releaseData }}>
  window.__releaseData = JSON.parse(releaseData);
</script>

<script>
  import Chart from 'chart.js/auto';
  import 'chartjs-adapter-date-fns';

  interface Release {
    tag: string;
    date: string;
    url: string;
    series: '1.x' | '2.x';
  }

  const COLORS = {
    '1.x': { bg: '#36a2eb', border: '#36a2eb' },
    '2.x': { bg: '#ff6d5a', border: '#ff6d5a' },
  };

  let chart: Chart | null = null;
  let allReleases: Release[] = [];

  function getDateRange(): number | 'all' {
    const value = (document.getElementById('release-date-range') as HTMLSelectElement).value;
    return value === 'all' ? 'all' : parseInt(value, 10);
  }

  function filterByMonths(releases: Release[], months: number | 'all'): Release[] {
    if (months === 'all') return releases;

    const now = new Date();
    const cutoffDate = new Date(now);
    cutoffDate.setMonth(cutoffDate.getMonth() - months);

    return releases.filter(r => new Date(r.date) >= cutoffDate);
  }

  function calcY(index: number, total: number): number {
    const minY = 0.5;
    const maxY = 4.5;
    if (total <= 1) return (minY + maxY) / 2;
    return minY + (index / (total - 1)) * (maxY - minY);
  }

  function createDatasets(releases: Release[]) {
    const series1x = releases.filter(r => r.series === '1.x');
    const series2x = releases.filter(r => r.series === '2.x');
    const datasets: any[] = [];

    if (series1x.length > 0) {
      datasets.push({
        label: '1.x releases',
        data: series1x.map((r, i) => ({
          x: new Date(r.date),
          y: calcY(i, series1x.length),
          tag: r.tag,
          url: r.url,
        })),
        backgroundColor: COLORS['1.x'].bg,
        borderColor: COLORS['1.x'].border,
        pointRadius: 5,
        pointHoverRadius: 8,
        showLine: false,
      });
    }

    if (series2x.length > 0) {
      datasets.push({
        label: '2.x releases',
        data: series2x.map((r, i) => ({
          x: new Date(r.date),
          y: calcY(i, series2x.length),
          tag: r.tag,
          url: r.url,
        })),
        backgroundColor: COLORS['2.x'].bg,
        borderColor: COLORS['2.x'].border,
        pointRadius: 5,
        pointHoverRadius: 8,
        showLine: false,
      });
    }

    return datasets;
  }

  function getDateBounds(releases: Release[]): { min: Date; max: Date } {
    const now = new Date();
    const max = new Date(now);
    max.setDate(max.getDate() + 14); // Add padding after current date

    let min: Date;
    if (releases.length > 0) {
      min = new Date(releases[0].date);
      min.setDate(min.getDate() - 14); // Add padding before first release
    } else {
      min = new Date(now);
      min.setMonth(min.getMonth() - 24);
    }

    return { min, max };
  }

  function updateChart() {
    if (!chart || allReleases.length === 0) return;

    const range = getDateRange();
    const filteredReleases = filterByMonths(allReleases, range);
    const datasets = createDatasets(filteredReleases);
    const { min, max } = getDateBounds(filteredReleases);

    // Update release count
    const countEl = document.getElementById('release-count');
    if (countEl) {
      countEl.textContent = `${filteredReleases.length} releases`;
    }

    chart.data.datasets = datasets;
    (chart.options.scales!.x as any).min = min.getTime();
    (chart.options.scales!.x as any).max = max.getTime();
    chart.update();
  }

  function initReleaseTimeline() {
    const canvas = document.getElementById('release-timeline-chart') as HTMLCanvasElement;
    const loadingEl = document.getElementById('release-timeline-loading');
    allReleases = (window as any).__releaseData || [];

    loadingEl?.classList.add('hidden');

    if (allReleases.length === 0) return;

    const range = getDateRange();
    const filteredReleases = filterByMonths(allReleases, range);
    const datasets = createDatasets(filteredReleases);
    const { min, max } = getDateBounds(filteredReleases);

    // Update initial release count
    const countEl = document.getElementById('release-count');
    if (countEl) {
      countEl.textContent = `${filteredReleases.length} releases`;
    }

    chart = new Chart(canvas, {
      type: 'scatter',
      data: { datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            backgroundColor: '#1e1e1e',
            titleColor: '#fff',
            bodyColor: '#9ca3af',
            borderColor: '#333',
            borderWidth: 1,
            callbacks: {
              title: (items) => {
                const item = items[0];
                const data = item.raw as any;
                return data.tag;
              },
              label: (item) => {
                const data = item.raw as any;
                const date = new Date(data.x);
                return date.toLocaleDateString('en-US', {
                  year: 'numeric',
                  month: 'short',
                  day: 'numeric',
                });
              },
            },
          },
        },
        scales: {
          x: {
            type: 'time',
            min: min.getTime(),
            max: max.getTime(),
            time: {
              unit: 'month',
              displayFormats: {
                month: 'MMM yyyy',
              },
            },
            grid: { color: 'rgba(255,255,255,0.05)' },
            ticks: {
              color: '#6b7280',
              maxRotation: 45,
            },
          },
          y: {
            min: 0,
            max: 5,
            grid: { display: false },
            ticks: {
              display: false,
            },
          },
        },
        onClick: (_event, elements) => {
          if (elements.length > 0 && chart) {
            const element = elements[0];
            const datasetIndex = element.datasetIndex;
            const index = element.index;
            const data = chart.data.datasets[datasetIndex].data[index] as any;
            if (data.url) {
              window.open(data.url, '_blank');
            }
          }
        },
        onHover: (event, elements) => {
          const canvas = event.native?.target as HTMLCanvasElement;
          if (canvas) {
            canvas.style.cursor = elements.length > 0 ? 'pointer' : 'default';
          }
        },
      },
    });

    // Attach event listener for range changes
    document.getElementById('release-date-range')?.addEventListener('change', updateChart);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initReleaseTimeline);
  } else {
    initReleaseTimeline();
  }
</script>

<style>
  #release-timeline-container {
    position: relative;
  }
</style>
