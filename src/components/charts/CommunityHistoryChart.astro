---
/**
 * Interactive Community History Chart
 *
 * Client-side component that:
 * - Loads history data from /data/community-history.json
 * - Renders Chart.js line/area chart
 * - Allows filtering by date range, metrics, and chart type
 */
---

<div id="community-chart-container" class="card">
  <!-- Controls -->
  <div class="flex flex-wrap items-center gap-4 mb-6">
    <!-- Date Range -->
    <div class="flex items-center gap-2">
      <label class="text-sm text-gray-400">Range:</label>
      <select id="community-date-range" class="bg-n8n-darker border border-n8n-border rounded px-3 py-1.5 text-sm text-gray-300 focus:outline-none focus:border-n8n-primary">
        <option value="365">Last 12 months</option>
        <option value="730" selected>Last 24 months</option>
        <option value="1095">Last 3 years</option>
        <option value="all">All time</option>
      </select>
    </div>

    <!-- Chart Type -->
    <div class="flex items-center gap-2">
      <label class="text-sm text-gray-400">Type:</label>
      <select id="community-chart-type" class="bg-n8n-darker border border-n8n-border rounded px-3 py-1.5 text-sm text-gray-300 focus:outline-none focus:border-n8n-primary">
        <option value="line">Line</option>
        <option value="area" selected>Area</option>
        <option value="bar">Bar</option>
      </select>
    </div>

    <!-- Metrics Toggle -->
    <div class="flex items-center gap-3 ml-auto">
      <label class="flex items-center gap-1.5 cursor-pointer">
        <input type="checkbox" id="community-toggle-users" checked class="accent-[#ff6384]" />
        <span class="text-sm text-gray-300">Users</span>
      </label>
      <label class="flex items-center gap-1.5 cursor-pointer">
        <input type="checkbox" id="community-toggle-topics" checked class="accent-[#36a2eb]" />
        <span class="text-sm text-gray-300">Topics</span>
      </label>
      <label class="flex items-center gap-1.5 cursor-pointer">
        <input type="checkbox" id="community-toggle-posts" class="accent-[#ffce56]" />
        <span class="text-sm text-gray-300">Posts</span>
      </label>
      <label class="flex items-center gap-1.5 cursor-pointer">
        <input type="checkbox" id="community-toggle-likes" class="accent-[#4bc0c0]" />
        <span class="text-sm text-gray-300">Likes</span>
      </label>
    </div>
  </div>

  <!-- Chart Canvas -->
  <div class="relative" style="height: 400px;">
    <canvas id="community-history-chart"></canvas>
  </div>

  <!-- Legend note for estimated data -->
  <p id="community-chart-note" class="text-xs text-gray-500 mt-2 text-center">
    <span class="inline-block border-t-2 border-dashed border-gray-400 w-4 align-middle mr-1"></span>
    Dashed lines indicate estimated data based on available historical snapshots
  </p>

  <!-- Loading/Error States -->
  <div id="community-chart-loading" class="absolute inset-0 flex items-center justify-center bg-n8n-card/80">
    <span class="text-gray-400">Loading chart data...</span>
  </div>
  <div id="community-chart-error" class="hidden absolute inset-0 flex items-center justify-center bg-n8n-card/80">
    <span class="text-red-400">Failed to load chart data</span>
  </div>
  <div id="community-chart-no-data" class="hidden absolute inset-0 flex items-center justify-center bg-n8n-card/80">
    <span class="text-gray-400">No historical data yet. Check back tomorrow!</span>
  </div>
</div>

<script>
  import Chart from 'chart.js/auto';

  interface CommunityDataPoint {
    date: string;
    users: number | null;
    topics: number | null;
    posts: number | null;
    likes: number | null;
    source?: string;
  }

  interface CommunityHistory {
    lastUpdated: string;
    daily: CommunityDataPoint[];
    weekly: CommunityDataPoint[];
    monthly: CommunityDataPoint[];
  }

  let communityChart: Chart | null = null;
  let communityHistoryData: CommunityHistory | null = null;

  const COMMUNITY_COLORS = {
    users: { border: '#ff6384', background: 'rgba(255, 99, 132, 0.1)' },
    topics: { border: '#36a2eb', background: 'rgba(54, 162, 235, 0.1)' },
    posts: { border: '#ffce56', background: 'rgba(255, 206, 86, 0.1)' },
    likes: { border: '#4bc0c0', background: 'rgba(75, 192, 192, 0.1)' },
  };

  async function loadCommunityData(): Promise<CommunityHistory | null> {
    try {
      const response = await fetch('/data/community-history.json');
      if (!response.ok) throw new Error('Failed to fetch');
      return await response.json();
    } catch (error) {
      console.error('Failed to load community history data:', error);
      return null;
    }
  }

  function getCommunityDataForRange(data: CommunityHistory, rangeDays: number | 'all'): CommunityDataPoint[] {
    if (rangeDays === 'all') {
      return data.monthly;
    } else if (rangeDays <= 90) {
      return data.daily;
    } else if (rangeDays <= 730) {
      return data.weekly;
    } else {
      // For 3 years (1095 days) or more, use monthly data
      return data.monthly;
    }
  }

  function parseDateToTimestamp(dateStr: string): number {
    // Handle different date formats:
    // Daily: "2026-01-08" (ISO date)
    // Weekly: "2024-W03" (ISO week)
    // Monthly: "2024-01" (year-month)

    if (dateStr.includes('-W')) {
      // Weekly format: "2024-W03"
      const [year, week] = dateStr.split('-W').map(Number);
      // Approximate: first day of that week
      const jan1 = new Date(year, 0, 1);
      const daysOffset = (week - 1) * 7;
      return jan1.getTime() + daysOffset * 24 * 60 * 60 * 1000;
    } else if (dateStr.match(/^\d{4}-\d{2}$/)) {
      // Monthly format: "2024-01"
      const [year, month] = dateStr.split('-').map(Number);
      return new Date(year, month - 1, 15).getTime(); // Mid-month
    } else {
      // Daily format: "2026-01-08"
      return new Date(dateStr).getTime();
    }
  }

  function filterCommunityByDateRange(points: CommunityDataPoint[], rangeDays: number | 'all'): CommunityDataPoint[] {
    if (rangeDays === 'all') return points;

    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - rangeDays);
    const cutoffTimestamp = cutoff.getTime();

    return points.filter(p => parseDateToTimestamp(p.date) >= cutoffTimestamp);
  }

  function getCommunityVisibleMetrics(): string[] {
    const metrics: string[] = [];
    if ((document.getElementById('community-toggle-users') as HTMLInputElement).checked) metrics.push('users');
    if ((document.getElementById('community-toggle-topics') as HTMLInputElement).checked) metrics.push('topics');
    if ((document.getElementById('community-toggle-posts') as HTMLInputElement).checked) metrics.push('posts');
    if ((document.getElementById('community-toggle-likes') as HTMLInputElement).checked) metrics.push('likes');
    return metrics;
  }

  function getCommunityChartType(): 'line' | 'bar' {
    return (document.getElementById('community-chart-type') as HTMLSelectElement).value as 'line' | 'bar';
  }

  function isCommunityAreaChart(): boolean {
    return (document.getElementById('community-chart-type') as HTMLSelectElement).value === 'area';
  }

  function getCommunityDateRange(): number | 'all' {
    const value = (document.getElementById('community-date-range') as HTMLSelectElement).value;
    return value === 'all' ? 'all' : parseInt(value, 10);
  }

  function createCommunityDatasets(data: CommunityDataPoint[], metrics: string[], chartType: 'line' | 'bar', isArea: boolean) {
    const metricLabels: Record<string, string> = {
      users: 'Members',
      topics: 'Topics',
      posts: 'Posts',
      likes: 'Likes',
    };

    // Check if any data is interpolated
    const hasInterpolated = data.some(d => d.source === 'interpolated');

    return metrics.map(metric => ({
      label: metricLabels[metric],
      // Chart.js handles null values as gaps in the line
      data: data.map(d => d[metric as keyof CommunityDataPoint] as number | null),
      borderColor: COMMUNITY_COLORS[metric as keyof typeof COMMUNITY_COLORS].border,
      backgroundColor: isArea ? COMMUNITY_COLORS[metric as keyof typeof COMMUNITY_COLORS].background : COMMUNITY_COLORS[metric as keyof typeof COMMUNITY_COLORS].border,
      fill: isArea,
      tension: 0,
      pointRadius: data.length > 60 ? 0 : 3,
      pointHoverRadius: 5,
      spanGaps: false, // Don't connect points across null values
      // Use secondary Y axis for posts (much larger scale)
      yAxisID: metric === 'posts' ? 'y1' : 'y',
      // Use dashed line segments for estimated data
      segment: {
        borderDash: (ctx: any) => {
          const index = ctx.p0DataIndex;
          const estimatedSources = ['interpolated', 'wayback-estimated', 'wayback-partial'];
          const isEstimated = estimatedSources.includes(data[index]?.source || '') ||
                              estimatedSources.includes(data[index + 1]?.source || '');
          return isEstimated ? [5, 5] : [];
        },
      },
    }));
  }

  // Store data reference for tooltip access
  let currentChartData: CommunityDataPoint[] = [];

  function updateCommunityChart() {
    if (!communityHistoryData) return;

    const range = getCommunityDateRange();
    const metrics = getCommunityVisibleMetrics();
    const chartType = getCommunityChartType();
    const isArea = isCommunityAreaChart();

    const rawData = getCommunityDataForRange(communityHistoryData, range);
    const filteredData = filterCommunityByDateRange(rawData, range);

    if (filteredData.length === 0) {
      document.getElementById('community-chart-no-data')?.classList.remove('hidden');
      return;
    }
    document.getElementById('community-chart-no-data')?.classList.add('hidden');

    // Store for tooltip access
    currentChartData = filteredData;

    const labels = filteredData.map(d => d.date);
    const datasets = createCommunityDatasets(filteredData, metrics, chartType, isArea);

    const hasPosts = metrics.includes('posts');
    const hasOtherMetrics = metrics.some(m => m !== 'posts');

    if (communityChart) {
      communityChart.data.labels = labels;
      communityChart.data.datasets = datasets;
      communityChart.config.type = chartType === 'bar' ? 'bar' : 'line';

      if (communityChart.options.scales) {
        communityChart.options.scales.y = {
          ...communityChart.options.scales.y,
          display: hasOtherMetrics,
        };
        communityChart.options.scales.y1 = {
          ...communityChart.options.scales.y1,
          display: hasPosts,
        };
      }

      communityChart.update();
    }
  }

  async function initCommunityChart() {
    const canvas = document.getElementById('community-history-chart') as HTMLCanvasElement;
    const loadingEl = document.getElementById('community-chart-loading');
    const errorEl = document.getElementById('community-chart-error');
    const noDataEl = document.getElementById('community-chart-no-data');

    communityHistoryData = await loadCommunityData();

    loadingEl?.classList.add('hidden');

    if (!communityHistoryData) {
      errorEl?.classList.remove('hidden');
      return;
    }

    if (communityHistoryData.daily.length === 0 && communityHistoryData.weekly.length === 0 && communityHistoryData.monthly.length === 0) {
      noDataEl?.classList.remove('hidden');
      return;
    }

    const range = getCommunityDateRange();
    const metrics = getCommunityVisibleMetrics();
    const isArea = isCommunityAreaChart();

    const rawData = getCommunityDataForRange(communityHistoryData, range);
    const filteredData = filterCommunityByDateRange(rawData, range);
    const labels = filteredData.map(d => d.date);
    const datasets = createCommunityDatasets(filteredData, metrics, 'line', isArea);

    communityChart = new Chart(canvas, {
      type: 'line',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        plugins: {
          legend: {
            display: true,
            position: 'bottom',
            labels: {
              color: '#9ca3af',
              usePointStyle: true,
              padding: 20,
            },
          },
          tooltip: {
            backgroundColor: '#1e1e1e',
            titleColor: '#fff',
            bodyColor: '#9ca3af',
            borderColor: '#333',
            borderWidth: 1,
            callbacks: {
              label: (context) => {
                const value = context.parsed.y;
                const dataPoint = currentChartData[context.dataIndex];
                const isEstimated = dataPoint?.source === 'interpolated' ||
                                    dataPoint?.source === 'wayback-estimated' ||
                                    dataPoint?.source === 'wayback-partial';
                const suffix = isEstimated ? ' (estimated)' : '';
                return `${context.dataset.label}: ${value.toLocaleString()}${suffix}`;
              },
            },
          },
        },
        scales: {
          x: {
            grid: { color: 'rgba(255,255,255,0.05)' },
            ticks: { color: '#6b7280', maxRotation: 45 },
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            grid: { color: 'rgba(255,255,255,0.05)' },
            ticks: {
              color: '#6b7280',
              callback: (value) => {
                if (typeof value === 'number') {
                  if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                  if (value >= 1000) return (value / 1000).toFixed(0) + 'K';
                }
                return value;
              },
            },
          },
          y1: {
            type: 'linear',
            display: metrics.includes('posts'),
            position: 'right',
            grid: { drawOnChartArea: false },
            ticks: {
              color: '#ffce56',
              callback: (value) => {
                if (typeof value === 'number') {
                  if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                  if (value >= 1000) return (value / 1000).toFixed(0) + 'K';
                }
                return value;
              },
            },
          },
        },
      },
    });

    // Attach event listeners
    document.getElementById('community-date-range')?.addEventListener('change', updateCommunityChart);
    document.getElementById('community-chart-type')?.addEventListener('change', updateCommunityChart);
    document.getElementById('community-toggle-users')?.addEventListener('change', updateCommunityChart);
    document.getElementById('community-toggle-topics')?.addEventListener('change', updateCommunityChart);
    document.getElementById('community-toggle-posts')?.addEventListener('change', updateCommunityChart);
    document.getElementById('community-toggle-likes')?.addEventListener('change', updateCommunityChart);
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCommunityChart);
  } else {
    initCommunityChart();
  }
</script>

<style>
  #community-chart-container {
    position: relative;
  }
</style>
