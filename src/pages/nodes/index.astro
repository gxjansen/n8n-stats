---
import BaseLayout from '@/layouts/BaseLayout.astro';
import NodeTreemapChart from '@/components/charts/NodeTreemapChart.astro';
import { fetchTemplates, aggregateNodeUsage } from '@/lib/api/n8n';
import { formatNumber, getNodeIntegrationUrl } from '@/lib/utils/formatters';
import { readFileSync } from 'fs';
import { join } from 'path';

// Load complete template data (fetched weekly)
let allTemplatesData: any = null;
try {
  const dataPath = join(process.cwd(), 'public', 'data', 'all-templates-data.json');
  allTemplatesData = JSON.parse(readFileSync(dataPath, 'utf-8'));
} catch (e) {
  console.warn('all-templates-data.json not found, using sample data');
}

// Load templates raw log for additional node data (includes core nodes like If, Set, etc.)
interface RawLogEntry {
  date: string;
  total: number;
  topNodes: { name: string; count: number }[];
}
let templatesRawLog: { entries: RawLogEntry[] } = { entries: [] };
try {
  const rawPath = join(process.cwd(), 'public', 'data', 'templates-raw-log.json');
  templatesRawLog = JSON.parse(readFileSync(rawPath, 'utf-8'));
} catch (e) {
  console.warn('templates-raw-log.json not found');
}

// Also fetch trending templates for comparison
const { workflows: trendingWorkflows } = await fetchTemplates({ rows: 100 });
const trendingNodeUsage = aggregateNodeUsage(trendingWorkflows);

// Use complete data if available, otherwise fall back to trending
const hasCompleteData = !!allTemplatesData?.nodes?.top100;

// Get nodes from all-templates-data.json (integration nodes)
let nodeUsage = hasCompleteData
  ? allTemplatesData.nodes.top100.map((n: any) => ({
      name: n.name,
      displayName: n.displayName,
      count: n.count,
      percentage: n.percentage,
      categories: n.categories || [],
    }))
  : trendingNodeUsage;

// Merge with templates-raw-log.json (includes core utility nodes like If, Set, etc.)
const latestRawEntry = templatesRawLog.entries?.[templatesRawLog.entries.length - 1];
if (latestRawEntry?.topNodes) {
  const existingNames = new Set(nodeUsage.map((n: any) => n.displayName.toLowerCase()));
  const totalTemplatesForPercentage = latestRawEntry.total || totalTemplates;

  // Add nodes from raw log that aren't already in nodeUsage
  const additionalNodes = latestRawEntry.topNodes
    .filter((n: { name: string; count: number }) => !existingNames.has(n.name.toLowerCase()))
    .map((n: { name: string; count: number }) => ({
      name: n.name,
      displayName: n.name,
      count: n.count,
      percentage: Math.round((n.count / totalTemplatesForPercentage) * 1000) / 10,
      categories: [],
    }));

  // Merge and re-sort by count
  nodeUsage = [...nodeUsage, ...additionalNodes].sort((a: any, b: any) => b.count - a.count);
}

const totalTemplates = allTemplatesData?.totalTemplates || 100;
const uniqueNodes = allTemplatesData?.nodes?.unique || nodeUsage.length;
const totalNodeUsages = allTemplatesData?.nodes?.total || 0;

// Group by category based on node names and API categories
const categorizeNode = (name: string, categories?: string[]) => {
  // Use API categories if available
  if (categories?.includes('AI') || categories?.includes('Langchain')) return 'AI';

  const lower = name.toLowerCase();

  // Exact match helper (for short names that could be substrings)
  const isExact = (word: string) => lower === word.toLowerCase();

  // Word boundary check helper (matches whole word only)
  const isWord = (word: string) => {
    const regex = new RegExp(`\\b${word}\\b`, 'i');
    return regex.test(name);
  };

  // Flow Control - check first to catch "If" before other rules
  if (isExact('if') || isExact('switch') || isExact('merge') || isExact('wait') ||
      lower.includes('split in batches') || lower.includes('loop over') ||
      lower.includes('no operation') || isExact('noop')) return 'Flow Control';

  // Triggers - workflow entry points
  if (isExact('schedule') || isExact('manual') || isExact('cron') ||
      lower.includes('trigger') || lower.includes('webhook')) return 'Triggers';

  // Communication - messaging and social
  if (isWord('slack') || isWord('discord') || isWord('telegram') || isWord('teams') ||
      lower.includes('whatsapp') || lower.includes('twilio') ||
      lower.includes('send email') || isWord('email') ||
      isWord('twitter') || lower.includes('x (formerly twitter)') ||
      isWord('linkedin') || isWord('facebook') && !lower.includes('graph api')) return 'Communication';

  // Google services
  if (isWord('google') || isWord('gmail')) return 'Google';

  // HTTP & APIs
  if (isWord('http') || lower === 'facebook graph api' || isWord('graphql') ||
      isWord('ftp') || isWord('sftp') || isWord('ssh')) return 'HTTP & APIs';

  // AI (non-API categorized)
  if (isWord('openai') || lower.includes('llm') || isWord('anthropic') ||
      lower.includes('langchain') || lower.includes('embedding') ||
      lower.includes('vector') || isWord('gemini') || isWord('claude')) return 'AI';

  // Database & Storage
  if (isWord('mysql') || isWord('postgres') || isWord('mongo') || isWord('database') ||
      isWord('redis') || isWord('sqlite') || isWord('supabase') ||
      isWord('airtable') || isWord('notion') || isWord('dynamodb') ||
      isWord('elasticsearch') || isWord('qdrant') || isWord('pinecone')) return 'Database & Storage';

  // Data Transform
  if (isWord('code') || lower.includes('function') || lower.includes('edit fields') ||
      lower.includes('aggregate') || lower === 'filter' || lower === 'sort' ||
      lower === 'limit' || lower.includes('split out') || lower.includes('html') ||
      lower.includes('json') || lower.includes('xml') || lower.includes('csv') ||
      lower.includes('convert') || lower.includes('set')) return 'Data Transform';

  // CRM & Sales
  if (isWord('hubspot') || isWord('salesforce') || isWord('pipedrive') ||
      isWord('zoho') || lower.includes('crm')) return 'CRM & Sales';

  // Productivity & Docs
  if (isWord('wordpress') || isWord('youtube') || isWord('jira') ||
      isWord('asana') || isWord('trello') || isWord('github') ||
      isWord('gitlab') || isWord('confluence')) return 'Productivity';

  // Utility (visual/organizational nodes)
  if (lower.includes('sticky note') || lower.includes('note')) return 'Utility';

  return 'Other';
};

const categoryOrder = ['Triggers', 'Flow Control', 'Data Transform', 'HTTP & APIs', 'AI', 'Communication', 'Google', 'Database & Storage', 'CRM & Sales', 'Productivity', 'Utility', 'Other'];

const nodesByCategory = nodeUsage.reduce((acc: Record<string, typeof nodeUsage>, node: any) => {
  const category = categorizeNode(node.displayName, node.categories);
  if (!acc[category]) acc[category] = [];
  acc[category].push(node);
  return acc;
}, {} as Record<string, typeof nodeUsage>);

const categoryColors: Record<string, string> = {
  'Triggers': '#22c55e',           // Green - entry points
  'Flow Control': '#ff9f40',       // Orange - logic flow
  'Data Transform': '#ffce56',     // Yellow - data manipulation
  'HTTP & APIs': '#ff6384',        // Red - external calls
  'AI': '#9966ff',                 // Purple - AI/ML
  'Communication': '#36a2eb',      // Blue - messaging
  'Google': '#4bc0c0',             // Teal - Google suite
  'Database & Storage': '#c9cbcf', // Gray - data storage
  'CRM & Sales': '#f472b6',        // Pink - sales tools
  'Productivity': '#a78bfa',       // Light purple - productivity
  'Utility': '#6b7280',            // Dark gray - utility nodes
  'Other': '#7c8798',              // Gray - uncategorized
};

// Prepare treemap data (top 50 nodes with categories)
const treemapData = nodeUsage.slice(0, 50).map((node: any) => ({
  name: node.displayName,
  count: node.count,
  category: categorizeNode(node.displayName, node.categories),
}));

// Get trending-specific nodes (nodes that appear more in trending than overall)
const getTrendingBoost = () => {
  if (!hasCompleteData) return [];

  const overallMap = new Map(nodeUsage.map((n: any) => [n.name, n.percentage || 0]));

  return trendingNodeUsage
    .slice(0, 30)
    .map(n => {
      const overallPct = overallMap.get(n.name) || 0;
      const trendingPct = (n.count / 100) * 100; // percentage in trending
      return {
        ...n,
        trendingPct,
        overallPct,
        boost: trendingPct - overallPct,
      };
    })
    .filter(n => n.boost > 5) // Nodes that are 5%+ more popular in trending
    .sort((a, b) => b.boost - a.boost)
    .slice(0, 10);
};

const trendingBoostNodes = getTrendingBoost();
---

<BaseLayout title="Node Statistics" description="Most popular nodes in n8n workflow templates">
  <div class="container-narrow py-12">
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-white mb-2">Node Statistics</h1>
      <p class="text-gray-400">
        Most used nodes across {formatNumber(totalTemplates)} workflow templates
      </p>
    </div>

    <!-- Overview Stats -->
    <section class="mb-12">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="card text-center">
          <div class="text-3xl font-bold text-n8n-primary mb-1">
            {formatNumber(totalTemplates)}
          </div>
          <div class="text-sm text-gray-400">Templates Analyzed</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-purple-400 mb-1">
            {uniqueNodes}
          </div>
          <div class="text-sm text-gray-400">Unique Nodes Used</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-cyan-400 mb-1">
            {formatNumber(totalNodeUsages)}
          </div>
          <div class="text-sm text-gray-400">Total Node Usages</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-green-400 mb-1">
            {hasCompleteData ? (totalNodeUsages / totalTemplates).toFixed(1) : '~4'}
          </div>
          <div class="text-sm text-gray-400">Avg Nodes/Template</div>
        </div>
      </div>
    </section>

    <!-- Node Usage Treemap -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-4">Node Usage Overview</h2>
      <p class="text-gray-400 mb-6">
        Rectangle size represents usage frequency across all templates. Colors indicate category.
      </p>
      <NodeTreemapChart data={treemapData} />
      <div class="flex flex-wrap gap-4 mt-4 text-sm">
        {categoryOrder.filter(cat => nodesByCategory[cat]?.length > 0).map((category) => (
          <span class="flex items-center gap-2">
            <span class="w-3 h-3 rounded" style={`background: ${categoryColors[category]}`}></span>
            {category}
          </span>
        ))}
      </div>
    </section>

    <!-- Top 10 Overall -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-6">Top 10 Most Used Nodes</h2>
      <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
        {nodeUsage.slice(0, 10).map((node: any, index: number) => (
          <div class="card text-center">
            <div class="text-3xl font-bold text-n8n-primary mb-2">#{index + 1}</div>
            <a
              href={getNodeIntegrationUrl(node.displayName)}
              target="_blank"
              rel="noopener noreferrer"
              class="font-medium text-white hover:text-n8n-primary transition-colors"
            >
              {node.displayName}
            </a>
            <div class="text-sm text-gray-400 mt-1">
              {formatNumber(node.count)} templates
            </div>
            {node.percentage && (
              <div class="text-xs text-gray-500">
                {node.percentage}% of all
              </div>
            )}
          </div>
        ))}
      </div>
    </section>

    <!-- Trending Boost Section -->
    {trendingBoostNodes.length > 0 && (
      <section class="mb-12">
        <h2 class="text-2xl font-bold text-white mb-2">Hot in Trending Templates</h2>
        <p class="text-gray-400 mb-6">
          Nodes that appear more often in the top 100 trending templates (ranked by n8n's trending score) compared to all {formatNumber(totalTemplates)} templates.
        </p>
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
          {trendingBoostNodes.map((node: any) => (
            <a
              href={getNodeIntegrationUrl(node.displayName)}
              target="_blank"
              rel="noopener noreferrer"
              class="card text-center hover:border-n8n-primary transition-colors"
            >
              <div class="font-medium text-white mb-1">{node.displayName}</div>
              <div class="text-sm">
                <span class="text-green-400">+{node.boost.toFixed(0)}%</span>
                <span class="text-gray-500"> vs overall</span>
              </div>
              <div class="text-xs text-gray-500 mt-1">
                {node.trendingPct.toFixed(0)}% trending vs {node.overallPct.toFixed(0)}% overall
              </div>
            </a>
          ))}
        </div>
      </section>
    )}

    <!-- By Category -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-2">Nodes by Category</h2>
      <p class="text-gray-400 mb-6">
        Top nodes in each category, ranked by usage across all {formatNumber(totalTemplates)} templates
      </p>

      <div class="space-y-8">
        {categoryOrder.map((category) => {
          const nodes = nodesByCategory[category];
          if (!nodes || nodes.length === 0) return null;
          const maxCount = nodes[0]?.count || 1;
          const color = categoryColors[category] || '#7c8798';

          return (
            <div class="card">
              <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                <span class="w-3 h-3 rounded" style={`background: ${color}`}></span>
                {category}
              </h3>
              <div class="space-y-3">
                {nodes.slice(0, 6).map((node: any) => {
                  const percentage = (node.count / maxCount) * 100;
                  return (
                    <a
                      href={getNodeIntegrationUrl(node.displayName)}
                      target="_blank"
                      rel="noopener noreferrer"
                      class="block group"
                    >
                      <div class="flex items-center justify-between mb-1">
                        <span class="text-sm text-gray-300 group-hover:text-white transition-colors">{node.displayName}</span>
                        <span class="text-sm text-gray-400">{formatNumber(node.count)}</span>
                      </div>
                      <div class="relative h-2 bg-gray-800 rounded overflow-hidden">
                        <div
                          class="absolute inset-y-0 left-0 rounded transition-all duration-300 group-hover:opacity-80"
                          style={`width: ${percentage}%; background: ${color};`}
                        />
                      </div>
                    </a>
                  );
                })}
              </div>
            </div>
          );
        })}
      </div>
    </section>

    <!-- Note -->
    <p class="text-sm text-gray-500 text-center mt-8">
      {hasCompleteData
        ? `Node data from ${formatNumber(totalTemplates)} templates. Note: Some categories (like Flow Control) have fewer nodes due to n8n API limitations on which nodes are included in template metadata.`
        : 'Statistics based on trending templates sample. Full data coming soon.'
      }
    </p>
  </div>
</BaseLayout>
