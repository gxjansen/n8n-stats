---
import BaseLayout from '@/layouts/BaseLayout.astro';
import NodeTreemapChart from '@/components/charts/NodeTreemapChart.astro';
import { fetchTemplates, aggregateNodeUsage } from '@/lib/api/n8n';
import { formatNumber, getNodeIntegrationUrl } from '@/lib/utils/formatters';
import { readFileSync } from 'fs';
import { join } from 'path';

// Load complete template data (fetched weekly)
let allTemplatesData: any = null;
try {
  const dataPath = join(process.cwd(), 'public', 'data', 'all-templates-data.json');
  allTemplatesData = JSON.parse(readFileSync(dataPath, 'utf-8'));
} catch (e) {
  console.warn('all-templates-data.json not found, using sample data');
}

// Also fetch trending templates for comparison
const { workflows: trendingWorkflows } = await fetchTemplates({ rows: 100 });
const trendingNodeUsage = aggregateNodeUsage(trendingWorkflows);

// Use complete data if available, otherwise fall back to trending
const hasCompleteData = !!allTemplatesData?.nodes?.top100;
const nodeUsage = hasCompleteData
  ? allTemplatesData.nodes.top100.map((n: any) => ({
      name: n.name,
      displayName: n.displayName,
      count: n.count,
      percentage: n.percentage,
      categories: n.categories || [],
    }))
  : trendingNodeUsage;

const totalTemplates = allTemplatesData?.totalTemplates || 100;
const uniqueNodes = allTemplatesData?.nodes?.unique || nodeUsage.length;
const totalNodeUsages = allTemplatesData?.nodes?.total || 0;

// Group by category (rough categorization based on node names)
const categorizeNode = (name: string, categories?: string[]) => {
  // Use API categories if available
  if (categories?.includes('AI') || categories?.includes('Langchain')) return 'AI';

  const lower = name.toLowerCase();
  if (lower.includes('google') || lower.includes('gmail') || lower.includes('sheets') || lower.includes('drive')) return 'Google';
  if (lower.includes('slack') || lower.includes('discord') || lower.includes('telegram') || lower.includes('teams')) return 'Communication';
  if (lower.includes('http') || lower.includes('webhook') || lower.includes('api')) return 'HTTP & Webhooks';
  if (lower.includes('openai') || lower.includes('ai') || lower.includes('llm') || lower.includes('anthropic') || lower.includes('langchain')) return 'AI';
  if (lower.includes('mysql') || lower.includes('postgres') || lower.includes('mongo') || lower.includes('database') || lower.includes('redis')) return 'Database';
  if (lower.includes('if') || lower.includes('switch') || lower.includes('merge') || lower.includes('split') || lower.includes('loop')) return 'Flow Control';
  if (lower.includes('code') || lower.includes('function') || lower.includes('set') || lower.includes('edit') || lower.includes('aggregate')) return 'Data Transform';
  return 'Other';
};

const nodesByCategory = nodeUsage.reduce((acc: Record<string, typeof nodeUsage>, node: any) => {
  const category = categorizeNode(node.displayName, node.categories);
  if (!acc[category]) acc[category] = [];
  acc[category].push(node);
  return acc;
}, {} as Record<string, typeof nodeUsage>);

const categoryOrder = ['HTTP & Webhooks', 'AI', 'Google', 'Communication', 'Data Transform', 'Flow Control', 'Database', 'Other'];

const categoryColors: Record<string, string> = {
  'HTTP & Webhooks': '#ff6384',
  'AI': '#9966ff',
  'Google': '#4bc0c0',
  'Communication': '#36a2eb',
  'Data Transform': '#ffce56',
  'Flow Control': '#ff9f40',
  'Database': '#c9cbcf',
  'Other': '#7c8798',
};

// Prepare treemap data (top 50 nodes with categories)
const treemapData = nodeUsage.slice(0, 50).map((node: any) => ({
  name: node.displayName,
  count: node.count,
  category: categorizeNode(node.displayName, node.categories),
}));

// Get trending-specific nodes (nodes that appear more in trending than overall)
const getTrendingBoost = () => {
  if (!hasCompleteData) return [];

  const overallMap = new Map(nodeUsage.map((n: any) => [n.name, n.percentage || 0]));

  return trendingNodeUsage
    .slice(0, 30)
    .map(n => {
      const overallPct = overallMap.get(n.name) || 0;
      const trendingPct = (n.count / 100) * 100; // percentage in trending
      return {
        ...n,
        trendingPct,
        overallPct,
        boost: trendingPct - overallPct,
      };
    })
    .filter(n => n.boost > 5) // Nodes that are 5%+ more popular in trending
    .sort((a, b) => b.boost - a.boost)
    .slice(0, 10);
};

const trendingBoostNodes = getTrendingBoost();
---

<BaseLayout title="Node Statistics" description="Most popular nodes in n8n workflow templates">
  <div class="container-narrow py-12">
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-white mb-2">Node Statistics</h1>
      <p class="text-gray-400">
        Most used nodes across {formatNumber(totalTemplates)} workflow templates
      </p>
    </div>

    <!-- Overview Stats -->
    <section class="mb-12">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="card text-center">
          <div class="text-3xl font-bold text-n8n-primary mb-1">
            {formatNumber(totalTemplates)}
          </div>
          <div class="text-sm text-gray-400">Templates Analyzed</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-purple-400 mb-1">
            {uniqueNodes}
          </div>
          <div class="text-sm text-gray-400">Unique Nodes Used</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-cyan-400 mb-1">
            {formatNumber(totalNodeUsages)}
          </div>
          <div class="text-sm text-gray-400">Total Node Usages</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-green-400 mb-1">
            {hasCompleteData ? (totalNodeUsages / totalTemplates).toFixed(1) : '~4'}
          </div>
          <div class="text-sm text-gray-400">Avg Nodes/Template</div>
        </div>
      </div>
    </section>

    <!-- Node Usage Treemap -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-4">Node Usage Overview</h2>
      <p class="text-gray-400 mb-6">
        Rectangle size represents usage frequency across all templates. Colors indicate category.
      </p>
      <NodeTreemapChart data={treemapData} />
      <div class="flex flex-wrap gap-4 mt-4 text-sm">
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #ff6384"></span> HTTP & Webhooks</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #9966ff"></span> AI</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #4bc0c0"></span> Google</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #36a2eb"></span> Communication</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #ffce56"></span> Data Transform</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #ff9f40"></span> Flow Control</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #c9cbcf"></span> Database</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #7c8798"></span> Other</span>
      </div>
    </section>

    <!-- Top 10 Overall -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-6">Top 10 Most Used Nodes</h2>
      <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
        {nodeUsage.slice(0, 10).map((node: any, index: number) => (
          <div class="card text-center">
            <div class="text-3xl font-bold text-n8n-primary mb-2">#{index + 1}</div>
            <a
              href={getNodeIntegrationUrl(node.displayName)}
              target="_blank"
              rel="noopener noreferrer"
              class="font-medium text-white hover:text-n8n-primary transition-colors"
            >
              {node.displayName}
            </a>
            <div class="text-sm text-gray-400 mt-1">
              {formatNumber(node.count)} templates
            </div>
            {node.percentage && (
              <div class="text-xs text-gray-500">
                {node.percentage}% of all
              </div>
            )}
          </div>
        ))}
      </div>
    </section>

    <!-- Trending Boost Section -->
    {trendingBoostNodes.length > 0 && (
      <section class="mb-12">
        <h2 class="text-2xl font-bold text-white mb-2">Hot in Trending Templates</h2>
        <p class="text-gray-400 mb-6">
          Nodes that appear more often in the top 100 trending templates (ranked by n8n's trending score) compared to all {formatNumber(totalTemplates)} templates.
        </p>
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
          {trendingBoostNodes.map((node: any) => (
            <a
              href={getNodeIntegrationUrl(node.displayName)}
              target="_blank"
              rel="noopener noreferrer"
              class="card text-center hover:border-n8n-primary transition-colors"
            >
              <div class="font-medium text-white mb-1">{node.displayName}</div>
              <div class="text-sm">
                <span class="text-green-400">+{node.boost.toFixed(0)}%</span>
                <span class="text-gray-500"> vs overall</span>
              </div>
              <div class="text-xs text-gray-500 mt-1">
                {node.trendingPct.toFixed(0)}% trending vs {node.overallPct.toFixed(0)}% overall
              </div>
            </a>
          ))}
        </div>
      </section>
    )}

    <!-- By Category -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-2">Nodes by Category</h2>
      <p class="text-gray-400 mb-6">
        Top nodes in each category, ranked by usage across all {formatNumber(totalTemplates)} templates
      </p>

      <div class="space-y-8">
        {categoryOrder.map((category) => {
          const nodes = nodesByCategory[category];
          if (!nodes || nodes.length === 0) return null;
          const maxCount = nodes[0]?.count || 1;
          const color = categoryColors[category] || '#7c8798';

          return (
            <div class="card">
              <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                <span class="w-3 h-3 rounded" style={`background: ${color}`}></span>
                {category}
              </h3>
              <div class="space-y-3">
                {nodes.slice(0, 6).map((node: any) => {
                  const percentage = (node.count / maxCount) * 100;
                  return (
                    <a
                      href={getNodeIntegrationUrl(node.displayName)}
                      target="_blank"
                      rel="noopener noreferrer"
                      class="block group"
                    >
                      <div class="flex items-center justify-between mb-1">
                        <span class="text-sm text-gray-300 group-hover:text-white transition-colors">{node.displayName}</span>
                        <span class="text-sm text-gray-400">{formatNumber(node.count)}</span>
                      </div>
                      <div class="relative h-2 bg-gray-800 rounded overflow-hidden">
                        <div
                          class="absolute inset-y-0 left-0 rounded transition-all duration-300 group-hover:opacity-80"
                          style={`width: ${percentage}%; background: ${color};`}
                        />
                      </div>
                    </a>
                  );
                })}
              </div>
            </div>
          );
        })}
      </div>
    </section>

    <!-- Note -->
    <p class="text-sm text-gray-500 text-center mt-8">
      {hasCompleteData
        ? `Complete data from ${formatNumber(totalTemplates)} templates. Updated weekly.`
        : 'Statistics based on trending templates sample. Full data coming soon.'
      }
    </p>
  </div>
</BaseLayout>
