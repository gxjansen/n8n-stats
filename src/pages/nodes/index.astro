---
import BaseLayout from '@/layouts/BaseLayout.astro';
import NodeTreemapChart from '@/components/charts/NodeTreemapChart.astro';
import CategoryNodesTable from '@/components/CategoryNodesTable.astro';
import { fetchTemplates, aggregateNodeUsage } from '@/lib/api/n8n';
import { formatNumber, getNodeIntegrationUrl, getNodePageUrl } from '@/lib/utils/formatters';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';

// Load complete node data (fetched weekly via fetch-all-nodes.ts)
interface NodeData {
  type: string;
  displayName: string;
  category: string;
  count: number;
  percentage: number;
}

interface AllNodesData {
  lastUpdated: string;
  fetchDuration: number;
  totalTemplates: number;
  nodes: {
    total: number;
    withData: number;
    byCategory: Record<string, NodeData[]>;
    all: NodeData[];
  };
}

let allNodesData: AllNodesData | null = null;
try {
  const dataPath = join(process.cwd(), 'public', 'data', 'all-nodes-data.json');
  allNodesData = JSON.parse(readFileSync(dataPath, 'utf-8'));
} catch (e) {
  console.warn('all-nodes-data.json not found, using fallback data');
}

// Load LLM models data from templates-raw-log
interface LLMModel {
  name: string;
  count: number;
}
let llmModels: LLMModel[] = [];
try {
  const rawLogPath = join(process.cwd(), 'public', 'data', 'templates-raw-log.json');
  if (existsSync(rawLogPath)) {
    const rawLog = JSON.parse(readFileSync(rawLogPath, 'utf-8'));
    const latestEntry = rawLog.entries?.[rawLog.entries.length - 1];
    llmModels = latestEntry?.llmModels || [];
  }
} catch (e) {
  console.warn('Could not load LLM models data');
}

// Calculate LLM statistics
const totalLLMTemplates = llmModels.reduce((sum, m) => sum + m.count, 0);
const topLLM = llmModels[0];
const openSourceLLMs = llmModels.filter(m =>
  ['Ollama Chat Model', 'Hugging Face Chat Model'].includes(m.name)
);
const cloudLLMs = llmModels.filter(m =>
  !['Ollama Chat Model', 'Hugging Face Chat Model'].includes(m.name)
);

// LLM brand colors
const llmColors: Record<string, string> = {
  'OpenAI Chat Model': '#10a37f',
  'Google Gemini Chat Model': '#4285f4',
  'OpenRouter Chat Model': '#6366f1',
  'Anthropic Chat Model': '#d4a574',
  'Azure OpenAI Chat Model': '#0078d4',
  'Groq Chat Model': '#f55036',
  'Ollama Chat Model': '#ffffff',
  'Mistral Cloud Chat Model': '#ff7000',
  'DeepSeek Chat Model': '#4d6bfe',
  'xAI Grok Chat Model': '#1da1f2',
  'Cohere Chat Model': '#39594d',
  'Hugging Face Chat Model': '#ffcc00',
};

function getLLMColor(name: string): string {
  return llmColors[name] || '#6b7280';
}

function getShortLLMName(name: string): string {
  return name
    .replace(' Chat Model', '')
    .replace('Google ', '')
    .replace(' Cloud', '');
}

// Also fetch trending templates for comparison
const { workflows: trendingWorkflows } = await fetchTemplates({ rows: 100 });
const trendingNodeUsage = aggregateNodeUsage(trendingWorkflows);

// Use complete data if available
const hasCompleteData = !!allNodesData?.nodes?.all;

// Get node data from all-nodes-data.json
const nodeUsage = hasCompleteData
  ? allNodesData.nodes.all.filter(n => n.count > 0).map(n => ({
      name: n.type,
      displayName: n.displayName,
      count: n.count,
      percentage: n.percentage,
      category: n.category,
    }))
  : trendingNodeUsage.map(n => ({ ...n, category: 'Other' }));

const totalTemplates = allNodesData?.totalTemplates || 100;
const uniqueNodes = allNodesData?.nodes?.withData || nodeUsage.length;
const totalNodes = allNodesData?.nodes?.total || uniqueNodes;

// Calculate total node usages
const totalNodeUsages = nodeUsage.reduce((sum: number, n: any) => sum + n.count, 0);

// Define category order and colors
const categoryOrder = [
  'Triggers',
  'Flow Control',
  'Data Transform',
  'HTTP & APIs',
  'AI',
  'Communication',
  'Google',
  'Database & Storage',
  'Files',
  'CRM & Sales',
  'Productivity',
  'Social Media',
  'E-Commerce',
  'Developer Tools',
  'CMS',
  'Marketing',
  'Utility',
  'Other'
];

const categoryColors: Record<string, string> = {
  'Triggers': '#22c55e',           // Green - entry points
  'Flow Control': '#ff9f40',       // Orange - logic flow
  'Data Transform': '#ffce56',     // Yellow - data manipulation
  'HTTP & APIs': '#ff6384',        // Red - external calls
  'AI': '#9966ff',                 // Purple - AI/ML
  'Communication': '#36a2eb',      // Blue - messaging
  'Google': '#4bc0c0',             // Teal - Google suite
  'Database & Storage': '#c9cbcf', // Gray - data storage
  'Files': '#8b5cf6',              // Violet - file operations
  'CRM & Sales': '#f472b6',        // Pink - sales tools
  'Productivity': '#a78bfa',       // Light purple - productivity
  'Social Media': '#06b6d4',       // Cyan - social
  'E-Commerce': '#f59e0b',         // Amber - e-commerce
  'Developer Tools': '#10b981',    // Emerald - dev tools
  'CMS': '#ec4899',                // Pink - content management
  'Marketing': '#ef4444',          // Red - marketing
  'Utility': '#6b7280',            // Dark gray - utility nodes
  'Other': '#7c8798',              // Gray - uncategorized
};

// Group nodes by category (using pre-categorized data)
const nodesByCategory: Record<string, typeof nodeUsage> = {};
if (hasCompleteData && allNodesData?.nodes?.byCategory) {
  for (const [category, nodes] of Object.entries(allNodesData.nodes.byCategory)) {
    const filteredNodes = nodes
      .filter((n: NodeData) => n.count > 0)
      .map((n: NodeData) => ({
        name: n.type,
        displayName: n.displayName,
        count: n.count,
        percentage: n.percentage,
        category: n.category,
      }));
    if (filteredNodes.length > 0) {
      nodesByCategory[category] = filteredNodes;
    }
  }
} else {
  // Fallback: group all nodes under 'Other'
  nodesByCategory['Other'] = nodeUsage;
}

// Prepare treemap data (top 50 nodes with categories)
const treemapData = nodeUsage.slice(0, 50).map((node: any) => ({
  name: node.displayName,
  count: node.count,
  category: node.category,
}));

// Get trending-specific nodes (nodes that appear more in trending than overall)
const getTrendingBoost = () => {
  if (!hasCompleteData) return [];

  const overallMap = new Map(nodeUsage.map((n: any) => [n.displayName, n.percentage || 0]));

  return trendingNodeUsage
    .slice(0, 30)
    .map(n => {
      const overallPct = overallMap.get(n.displayName) || 0;
      const trendingPct = (n.count / 100) * 100; // percentage in trending
      return {
        ...n,
        trendingPct,
        overallPct,
        boost: trendingPct - overallPct,
      };
    })
    .filter(n => n.boost > 5) // Nodes that are 5%+ more popular in trending
    .sort((a, b) => b.boost - a.boost)
    .slice(0, 10);
};

const trendingBoostNodes = getTrendingBoost();

// Get unused nodes (0 templates)
const unusedNodes = hasCompleteData
  ? allNodesData.nodes.all
      .filter((n: NodeData) => n.count === 0)
      .map((n: NodeData) => ({
        displayName: n.displayName,
        category: n.category,
        type: n.type,
      }))
  : [];

// Format last updated date
const lastUpdated = allNodesData?.lastUpdated
  ? new Date(allNodesData.lastUpdated).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    })
  : null;
---

<BaseLayout title="Node Statistics" description="Most popular nodes in n8n workflow templates">
  <div class="container-narrow py-12">
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-white mb-2">Node Statistics</h1>
      <p class="text-gray-400">
        Usage statistics for {totalNodes} n8n nodes across {formatNumber(totalTemplates)} workflow templates
      </p>
    </div>

    <!-- Overview Stats -->
    <section class="mb-12">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="card text-center">
          <div class="text-3xl font-bold text-n8n-primary mb-1">
            {formatNumber(totalTemplates)}
          </div>
          <div class="text-sm text-gray-400">Templates Analyzed</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-purple-400 mb-1">
            {uniqueNodes}
          </div>
          <div class="text-sm text-gray-400">Nodes With Usage</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-cyan-400 mb-1">
            {formatNumber(totalNodeUsages)}
          </div>
          <div class="text-sm text-gray-400">Total Node Usages</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-green-400 mb-1">
            {Object.keys(nodesByCategory).length}
          </div>
          <div class="text-sm text-gray-400">Categories</div>
        </div>
      </div>
    </section>

    <!-- Node Usage Treemap -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-4">Node Usage Overview</h2>
      <p class="text-gray-400 mb-6">
        Rectangle size represents usage frequency across all templates. Colors indicate category.
      </p>
      <NodeTreemapChart data={treemapData} />
      <div class="flex flex-wrap gap-4 mt-4 text-sm">
        {categoryOrder.filter(cat => nodesByCategory[cat]?.length > 0).map((category) => (
          <span class="flex items-center gap-2">
            <span class="w-3 h-3 rounded" style={`background: ${categoryColors[category]}`}></span>
            {category}
          </span>
        ))}
      </div>
    </section>

    <!-- Top 10 Overall -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-6">Top 10 Most Used Nodes</h2>
      <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
        {nodeUsage.slice(0, 10).map((node: any, index: number) => (
          <a
            href={getNodePageUrl(node.displayName)}
            class="card text-center hover:border-n8n-primary transition-colors"
          >
            <div class="text-3xl font-bold text-n8n-primary mb-2">#{index + 1}</div>
            <span class="font-medium text-white">
              {node.displayName}
            </span>
            <div class="text-sm text-gray-400 mt-1">
              {formatNumber(node.count)} templates
            </div>
            {node.percentage && (
              <div class="text-xs text-gray-500">
                {node.percentage}% of all
              </div>
            )}
          </a>
        ))}
      </div>
    </section>

    <!-- LLM Models Section -->
    {llmModels.length > 0 && (
      <section id="llm-models" class="mb-12 scroll-mt-20">
        <div class="flex items-center gap-3 mb-2">
          <h2 class="text-2xl font-bold text-white">LLM Provider Breakdown</h2>
          <span class="px-2 py-0.5 bg-emerald-500/10 text-emerald-400 text-xs font-medium rounded">AI</span>
        </div>
        <p class="text-gray-400 mb-6">
          Language model nodes used across {formatNumber(totalLLMTemplates)} AI-powered templates.
        </p>

        <!-- LLM Stats Grid -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
          <div class="card text-center">
            <div class="text-3xl font-bold text-emerald-400 mb-1">
              {llmModels.length}
            </div>
            <div class="text-sm text-gray-400">LLM Providers</div>
          </div>
          <div class="card text-center">
            <div class="text-3xl font-bold text-white mb-1">
              {formatNumber(totalLLMTemplates)}
            </div>
            <div class="text-sm text-gray-400">Templates with LLMs</div>
          </div>
          <div class="card text-center">
            <div class="text-3xl font-bold mb-1" style={`color: ${getLLMColor(topLLM?.name || '')}`}>
              {topLLM ? Math.round((topLLM.count / totalLLMTemplates) * 100) : 0}%
            </div>
            <div class="text-sm text-gray-400">{getShortLLMName(topLLM?.name || 'OpenAI')} Dominance</div>
          </div>
          <div class="card text-center">
            <div class="text-3xl font-bold text-gray-400 mb-1">
              {openSourceLLMs.reduce((sum, m) => sum + m.count, 0)}
            </div>
            <div class="text-sm text-gray-400">Self-Hosted (Ollama)</div>
          </div>
        </div>

        <!-- Full LLM Chart -->
        <div class="card p-6 mb-6">
          <h3 class="text-lg font-semibold text-white mb-4">Market Share by Provider</h3>
          <div class="space-y-3">
            {llmModels.map((model, i) => {
              const pct = (model.count / totalLLMTemplates) * 100;
              const maxPct = (llmModels[0]?.count / totalLLMTemplates) * 100;
              const barWidth = (pct / maxPct) * 100;
              const color = getLLMColor(model.name);
              return (
                <div class="group">
                  <div class="flex items-center justify-between mb-1">
                    <div class="flex items-center gap-2">
                      <span class="text-gray-500 w-6 text-right">#{i + 1}</span>
                      <span
                        class="w-3 h-3 rounded-full flex-shrink-0"
                        style={`background: ${color}`}
                      />
                      <span class="text-white font-medium">{getShortLLMName(model.name)}</span>
                    </div>
                    <div class="flex items-center gap-4">
                      <span class="text-gray-400">{formatNumber(model.count)} templates</span>
                      <span class="text-white font-semibold w-14 text-right">{pct.toFixed(1)}%</span>
                    </div>
                  </div>
                  <div class="ml-8 h-6 bg-gray-800 rounded overflow-hidden">
                    <div
                      class="h-full rounded transition-all duration-500 group-hover:opacity-80"
                      style={`width: ${barWidth}%; background: ${color}`}
                    />
                  </div>
                </div>
              );
            })}
          </div>
        </div>

        <!-- Cloud vs Open Source Comparison -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Cloud Providers -->
          <div class="card p-6">
            <div class="flex items-center gap-2 mb-4">
              <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" />
              </svg>
              <h3 class="text-lg font-semibold text-white">Cloud Providers</h3>
            </div>
            <div class="space-y-2">
              {cloudLLMs.slice(0, 6).map((model) => {
                const pct = (model.count / totalLLMTemplates) * 100;
                return (
                  <div class="flex items-center justify-between p-2 rounded bg-gray-800/50">
                    <div class="flex items-center gap-2">
                      <span
                        class="w-2 h-2 rounded-full"
                        style={`background: ${getLLMColor(model.name)}`}
                      />
                      <span class="text-white text-sm">{getShortLLMName(model.name)}</span>
                    </div>
                    <div class="text-sm">
                      <span class="text-gray-400">{formatNumber(model.count)}</span>
                      <span class="text-gray-600 ml-1">({pct.toFixed(1)}%)</span>
                    </div>
                  </div>
                );
              })}
            </div>
            <div class="mt-4 pt-4 border-t border-gray-700">
              <div class="flex justify-between text-sm">
                <span class="text-gray-400">Total Cloud Usage</span>
                <span class="text-white font-medium">
                  {formatNumber(cloudLLMs.reduce((sum, m) => sum + m.count, 0))} templates
                </span>
              </div>
            </div>
          </div>

          <!-- Open Source / Self-Hosted -->
          <div class="card p-6">
            <div class="flex items-center gap-2 mb-4">
              <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" />
              </svg>
              <h3 class="text-lg font-semibold text-white">Open Source / Self-Hosted</h3>
            </div>
            {openSourceLLMs.length > 0 ? (
              <div class="space-y-2">
                {openSourceLLMs.map((model) => {
                  const pct = (model.count / totalLLMTemplates) * 100;
                  return (
                    <div class="flex items-center justify-between p-2 rounded bg-gray-800/50">
                      <div class="flex items-center gap-2">
                        <span
                          class="w-2 h-2 rounded-full"
                          style={`background: ${getLLMColor(model.name)}`}
                        />
                        <span class="text-white text-sm">{getShortLLMName(model.name)}</span>
                      </div>
                      <div class="text-sm">
                        <span class="text-gray-400">{formatNumber(model.count)}</span>
                        <span class="text-gray-600 ml-1">({pct.toFixed(1)}%)</span>
                      </div>
                    </div>
                  );
                })}
              </div>
            ) : (
              <p class="text-gray-500 text-sm">No open source LLM usage tracked yet.</p>
            )}
            <div class="mt-4 pt-4 border-t border-gray-700">
              <div class="flex justify-between text-sm">
                <span class="text-gray-400">Total Self-Hosted Usage</span>
                <span class="text-white font-medium">
                  {formatNumber(openSourceLLMs.reduce((sum, m) => sum + m.count, 0))} templates
                </span>
              </div>
            </div>
            <p class="text-xs text-gray-500 mt-3">
              Self-hosted options like Ollama let you run models locally without API costs.
            </p>
          </div>
        </div>
      </section>
    )}

    <!-- Trending Boost Section -->
    {trendingBoostNodes.length > 0 && (
      <section class="mb-12">
        <h2 class="text-2xl font-bold text-white mb-2">Hot in Trending Templates</h2>
        <p class="text-gray-400 mb-6">
          Nodes that appear more often in the top 100 trending templates compared to all {formatNumber(totalTemplates)} templates.
        </p>
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
          {trendingBoostNodes.map((node: any) => (
            <a
              href={getNodePageUrl(node.displayName)}
              class="card text-center hover:border-n8n-primary transition-colors"
            >
              <div class="font-medium text-white mb-1">{node.displayName}</div>
              <div class="text-sm">
                <span class="text-green-400">+{node.boost.toFixed(0)}%</span>
                <span class="text-gray-500"> vs overall</span>
              </div>
              <div class="text-xs text-gray-500 mt-1">
                {node.trendingPct.toFixed(0)}% trending vs {node.overallPct.toFixed(0)}% overall
              </div>
            </a>
          ))}
        </div>
      </section>
    )}

    <!-- By Category - Compact Table Grid -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-2">Top Nodes by Category</h2>
      <p class="text-gray-400 mb-6">
        Top 5 nodes in each category, ranked by template usage. Click any node to view details.
      </p>
      <CategoryNodesTable
        data={nodesByCategory}
        categoryOrder={categoryOrder}
        categoryColors={categoryColors}
        nodesPerCategory={5}
      />
    </section>

    <!-- Unused Nodes Section -->
    {unusedNodes.length > 0 && (
      <section class="mb-12">
        <h2 class="text-2xl font-bold text-white mb-2">Nodes With Zero Usage</h2>
        <p class="text-gray-400 mb-6">
          These {unusedNodes.length} nodes don't appear in any of the {formatNumber(totalTemplates)} public templates.
        </p>
        <div class="card p-6">
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {unusedNodes.map((node: any) => {
              const color = categoryColors[node.category] || '#7c8798';
              return (
                <a
                  href={getNodePageUrl(node.displayName)}
                  class="flex items-center gap-3 p-3 rounded-lg bg-gray-800/50 hover:bg-gray-800 transition-colors"
                >
                  <span
                    class="w-2 h-2 rounded-full flex-shrink-0"
                    style={`background: ${color}`}
                  />
                  <div class="min-w-0">
                    <div class="text-sm font-medium text-white truncate">
                      {node.displayName}
                    </div>
                    <div class="text-xs text-gray-500">
                      {node.category}
                    </div>
                  </div>
                  <span class="ml-auto text-xs text-gray-600 flex-shrink-0">
                    0 templates
                  </span>
                </a>
              );
            })}
          </div>
          <p class="text-xs text-gray-500 mt-4">
            Some nodes have zero public usage because: they're development tools (Debug),
            redundant with other platforms (Zapier), or only have trigger variants that are tracked separately
            (Typeform, Calendly, Discord action nodes vs their Trigger counterparts).
          </p>
        </div>
      </section>
    )}

    <!-- Note -->
    <p class="text-sm text-gray-500 text-center mt-8">
      {hasCompleteData
        ? `Data collected by querying each of ${totalNodes} nodes individually against ${formatNumber(totalTemplates)} templates.${lastUpdated ? ` Last updated: ${lastUpdated}.` : ''}`
        : 'Statistics based on trending templates sample. Full data coming soon.'
      }
    </p>
  </div>
</BaseLayout>
