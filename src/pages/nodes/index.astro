---
import BaseLayout from '@/layouts/BaseLayout.astro';
import NodeTreemapChart from '@/components/charts/NodeTreemapChart.astro';
import { fetchTemplates, aggregateNodeUsage } from '@/lib/api/n8n';
import { formatNumber, getNodeIntegrationUrl } from '@/lib/utils/formatters';
import { readFileSync } from 'fs';
import { join } from 'path';

// Load complete template data (fetched weekly)
let allTemplatesData: any = null;
try {
  const dataPath = join(process.cwd(), 'public', 'data', 'all-templates-data.json');
  allTemplatesData = JSON.parse(readFileSync(dataPath, 'utf-8'));
} catch (e) {
  console.warn('all-templates-data.json not found, using sample data');
}

// Load templates raw log for additional node data (includes core nodes like If, Set, etc.)
interface RawLogEntry {
  date: string;
  total: number;
  topNodes: { name: string; count: number }[];
}
let templatesRawLog: { entries: RawLogEntry[] } = { entries: [] };
try {
  const rawPath = join(process.cwd(), 'public', 'data', 'templates-raw-log.json');
  templatesRawLog = JSON.parse(readFileSync(rawPath, 'utf-8'));
} catch (e) {
  console.warn('templates-raw-log.json not found');
}

// Also fetch trending templates for comparison
const { workflows: trendingWorkflows } = await fetchTemplates({ rows: 100 });
const trendingNodeUsage = aggregateNodeUsage(trendingWorkflows);

// Use complete data if available, otherwise fall back to trending
const hasCompleteData = !!allTemplatesData?.nodes?.top100;

// Get nodes from all-templates-data.json (integration nodes)
let nodeUsage = hasCompleteData
  ? allTemplatesData.nodes.top100.map((n: any) => ({
      name: n.name,
      displayName: n.displayName,
      count: n.count,
      percentage: n.percentage,
      categories: n.categories || [],
    }))
  : trendingNodeUsage;

// Merge with templates-raw-log.json (includes core utility nodes like If, Set, etc.)
const latestRawEntry = templatesRawLog.entries?.[templatesRawLog.entries.length - 1];
if (latestRawEntry?.topNodes) {
  const existingNames = new Set(nodeUsage.map((n: any) => n.displayName.toLowerCase()));
  const totalTemplatesForPercentage = latestRawEntry.total || totalTemplates;

  // Add nodes from raw log that aren't already in nodeUsage
  const additionalNodes = latestRawEntry.topNodes
    .filter((n: { name: string; count: number }) => !existingNames.has(n.name.toLowerCase()))
    .map((n: { name: string; count: number }) => ({
      name: n.name,
      displayName: n.name,
      count: n.count,
      percentage: Math.round((n.count / totalTemplatesForPercentage) * 1000) / 10,
      categories: [],
    }));

  // Merge and re-sort by count
  nodeUsage = [...nodeUsage, ...additionalNodes].sort((a: any, b: any) => b.count - a.count);
}

const totalTemplates = allTemplatesData?.totalTemplates || 100;
const uniqueNodes = allTemplatesData?.nodes?.unique || nodeUsage.length;
const totalNodeUsages = allTemplatesData?.nodes?.total || 0;

// Group by category (rough categorization based on node names)
const categorizeNode = (name: string, categories?: string[]) => {
  // Use API categories if available
  if (categories?.includes('AI') || categories?.includes('Langchain')) return 'AI';

  const lower = name.toLowerCase();

  // Word boundary check helper (matches whole word only)
  const isWord = (word: string) => {
    const regex = new RegExp(`\\b${word}\\b`, 'i');
    return regex.test(name);
  };

  // Google services (exclude false positives like "Pipedrive")
  if (isWord('google') || isWord('gmail') || lower === 'google sheets' || lower === 'google drive' || lower === 'google docs' || lower === 'google calendar') return 'Google';

  // Communication
  if (isWord('slack') || isWord('discord') || isWord('telegram') || isWord('teams') || lower.includes('whatsapp') || lower.includes('twilio')) return 'Communication';

  // HTTP & Webhooks
  if (isWord('http') || isWord('webhook') || lower === 'facebook graph api') return 'HTTP & Webhooks';

  // AI (non-API categorized)
  if (isWord('openai') || lower.includes('llm') || isWord('anthropic') || lower.includes('langchain') || lower.includes('embedding') || lower.includes('vector')) return 'AI';

  // Database
  if (isWord('mysql') || isWord('postgres') || isWord('mongo') || isWord('database') || isWord('redis') || isWord('sqlite') || isWord('supabase')) return 'Database';

  // Flow Control (exact matches to avoid "Shopify" matching "if")
  if (lower === 'if' || isWord('switch') || isWord('merge') || lower.includes('split in batches') || lower.includes('loop over') || lower === 'wait') return 'Flow Control';

  // Data Transform
  if (isWord('code') || lower.includes('function') || lower.includes('edit fields') || lower.includes('aggregate') || lower.includes('filter') || lower === 'split out') return 'Data Transform';

  return 'Other';
};

const nodesByCategory = nodeUsage.reduce((acc: Record<string, typeof nodeUsage>, node: any) => {
  const category = categorizeNode(node.displayName, node.categories);
  if (!acc[category]) acc[category] = [];
  acc[category].push(node);
  return acc;
}, {} as Record<string, typeof nodeUsage>);

const categoryOrder = ['HTTP & Webhooks', 'AI', 'Google', 'Communication', 'Data Transform', 'Flow Control', 'Database', 'Other'];

const categoryColors: Record<string, string> = {
  'HTTP & Webhooks': '#ff6384',
  'AI': '#9966ff',
  'Google': '#4bc0c0',
  'Communication': '#36a2eb',
  'Data Transform': '#ffce56',
  'Flow Control': '#ff9f40',
  'Database': '#c9cbcf',
  'Other': '#7c8798',
};

// Prepare treemap data (top 50 nodes with categories)
const treemapData = nodeUsage.slice(0, 50).map((node: any) => ({
  name: node.displayName,
  count: node.count,
  category: categorizeNode(node.displayName, node.categories),
}));

// Get trending-specific nodes (nodes that appear more in trending than overall)
const getTrendingBoost = () => {
  if (!hasCompleteData) return [];

  const overallMap = new Map(nodeUsage.map((n: any) => [n.name, n.percentage || 0]));

  return trendingNodeUsage
    .slice(0, 30)
    .map(n => {
      const overallPct = overallMap.get(n.name) || 0;
      const trendingPct = (n.count / 100) * 100; // percentage in trending
      return {
        ...n,
        trendingPct,
        overallPct,
        boost: trendingPct - overallPct,
      };
    })
    .filter(n => n.boost > 5) // Nodes that are 5%+ more popular in trending
    .sort((a, b) => b.boost - a.boost)
    .slice(0, 10);
};

const trendingBoostNodes = getTrendingBoost();
---

<BaseLayout title="Node Statistics" description="Most popular nodes in n8n workflow templates">
  <div class="container-narrow py-12">
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-white mb-2">Node Statistics</h1>
      <p class="text-gray-400">
        Most used nodes across {formatNumber(totalTemplates)} workflow templates
      </p>
    </div>

    <!-- Overview Stats -->
    <section class="mb-12">
      <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div class="card text-center">
          <div class="text-3xl font-bold text-n8n-primary mb-1">
            {formatNumber(totalTemplates)}
          </div>
          <div class="text-sm text-gray-400">Templates Analyzed</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-purple-400 mb-1">
            {uniqueNodes}
          </div>
          <div class="text-sm text-gray-400">Unique Nodes Used</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-cyan-400 mb-1">
            {formatNumber(totalNodeUsages)}
          </div>
          <div class="text-sm text-gray-400">Total Node Usages</div>
        </div>
        <div class="card text-center">
          <div class="text-3xl font-bold text-green-400 mb-1">
            {hasCompleteData ? (totalNodeUsages / totalTemplates).toFixed(1) : '~4'}
          </div>
          <div class="text-sm text-gray-400">Avg Nodes/Template</div>
        </div>
      </div>
    </section>

    <!-- Node Usage Treemap -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-4">Node Usage Overview</h2>
      <p class="text-gray-400 mb-6">
        Rectangle size represents usage frequency across all templates. Colors indicate category.
      </p>
      <NodeTreemapChart data={treemapData} />
      <div class="flex flex-wrap gap-4 mt-4 text-sm">
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #ff6384"></span> HTTP & Webhooks</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #9966ff"></span> AI</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #4bc0c0"></span> Google</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #36a2eb"></span> Communication</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #ffce56"></span> Data Transform</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #ff9f40"></span> Flow Control</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #c9cbcf"></span> Database</span>
        <span class="flex items-center gap-2"><span class="w-3 h-3 rounded" style="background: #7c8798"></span> Other</span>
      </div>
    </section>

    <!-- Top 10 Overall -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-6">Top 10 Most Used Nodes</h2>
      <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
        {nodeUsage.slice(0, 10).map((node: any, index: number) => (
          <div class="card text-center">
            <div class="text-3xl font-bold text-n8n-primary mb-2">#{index + 1}</div>
            <a
              href={getNodeIntegrationUrl(node.displayName)}
              target="_blank"
              rel="noopener noreferrer"
              class="font-medium text-white hover:text-n8n-primary transition-colors"
            >
              {node.displayName}
            </a>
            <div class="text-sm text-gray-400 mt-1">
              {formatNumber(node.count)} templates
            </div>
            {node.percentage && (
              <div class="text-xs text-gray-500">
                {node.percentage}% of all
              </div>
            )}
          </div>
        ))}
      </div>
    </section>

    <!-- Trending Boost Section -->
    {trendingBoostNodes.length > 0 && (
      <section class="mb-12">
        <h2 class="text-2xl font-bold text-white mb-2">Hot in Trending Templates</h2>
        <p class="text-gray-400 mb-6">
          Nodes that appear more often in the top 100 trending templates (ranked by n8n's trending score) compared to all {formatNumber(totalTemplates)} templates.
        </p>
        <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
          {trendingBoostNodes.map((node: any) => (
            <a
              href={getNodeIntegrationUrl(node.displayName)}
              target="_blank"
              rel="noopener noreferrer"
              class="card text-center hover:border-n8n-primary transition-colors"
            >
              <div class="font-medium text-white mb-1">{node.displayName}</div>
              <div class="text-sm">
                <span class="text-green-400">+{node.boost.toFixed(0)}%</span>
                <span class="text-gray-500"> vs overall</span>
              </div>
              <div class="text-xs text-gray-500 mt-1">
                {node.trendingPct.toFixed(0)}% trending vs {node.overallPct.toFixed(0)}% overall
              </div>
            </a>
          ))}
        </div>
      </section>
    )}

    <!-- By Category -->
    <section class="mb-12">
      <h2 class="text-2xl font-bold text-white mb-2">Nodes by Category</h2>
      <p class="text-gray-400 mb-6">
        Top nodes in each category, ranked by usage across all {formatNumber(totalTemplates)} templates
      </p>

      <div class="space-y-8">
        {categoryOrder.map((category) => {
          const nodes = nodesByCategory[category];
          if (!nodes || nodes.length === 0) return null;
          const maxCount = nodes[0]?.count || 1;
          const color = categoryColors[category] || '#7c8798';

          return (
            <div class="card">
              <h3 class="text-lg font-semibold text-white mb-4 flex items-center gap-2">
                <span class="w-3 h-3 rounded" style={`background: ${color}`}></span>
                {category}
              </h3>
              <div class="space-y-3">
                {nodes.slice(0, 6).map((node: any) => {
                  const percentage = (node.count / maxCount) * 100;
                  return (
                    <a
                      href={getNodeIntegrationUrl(node.displayName)}
                      target="_blank"
                      rel="noopener noreferrer"
                      class="block group"
                    >
                      <div class="flex items-center justify-between mb-1">
                        <span class="text-sm text-gray-300 group-hover:text-white transition-colors">{node.displayName}</span>
                        <span class="text-sm text-gray-400">{formatNumber(node.count)}</span>
                      </div>
                      <div class="relative h-2 bg-gray-800 rounded overflow-hidden">
                        <div
                          class="absolute inset-y-0 left-0 rounded transition-all duration-300 group-hover:opacity-80"
                          style={`width: ${percentage}%; background: ${color};`}
                        />
                      </div>
                    </a>
                  );
                })}
              </div>
            </div>
          );
        })}
      </div>
    </section>

    <!-- Note -->
    <p class="text-sm text-gray-500 text-center mt-8">
      {hasCompleteData
        ? `Complete data from ${formatNumber(totalTemplates)} templates. Updated weekly.`
        : 'Statistics based on trending templates sample. Full data coming soon.'
      }
    </p>
  </div>
</BaseLayout>
